<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - fuzzer/fuzzer.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">fuzzer</a> - fuzzer.h<span style="font-size: 80%;"> (source / <a href="fuzzer.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">641</td>
            <td class="headerCovTableEntry">817</td>
            <td class="headerCovTableEntryMed">78.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2025-01-20 19:12:53</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">121</td>
            <td class="headerCovTableEntry">145</td>
            <td class="headerCovTableEntryMed">83.4 %</td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : #pragma once</a>
<a name="2"><span class="lineNum">       2 </span>            : #include &lt;iostream&gt;</a>
<a name="3"><span class="lineNum">       3 </span>            : #include &lt;random&gt;</a>
<a name="4"><span class="lineNum">       4 </span>            : #include &lt;string&gt;</a>
<a name="5"><span class="lineNum">       5 </span>            : #include &lt;stdexcept&gt;</a>
<a name="6"><span class="lineNum">       6 </span>            : #include &lt;boost/process.hpp&gt;</a>
<a name="7"><span class="lineNum">       7 </span>            : #include &lt;chrono&gt;</a>
<a name="8"><span class="lineNum">       8 </span>            : #include &lt;optional&gt;</a>
<a name="9"><span class="lineNum">       9 </span>            : #include &lt;thread&gt;</a>
<a name="10"><span class="lineNum">      10 </span>            : #include &lt;future&gt;</a>
<a name="11"><span class="lineNum">      11 </span>            : #include &lt;sstream&gt;</a>
<a name="12"><span class="lineNum">      12 </span>            : #include &lt;filesystem&gt;</a>
<a name="13"><span class="lineNum">      13 </span>            : #include &lt;fstream&gt;</a>
<a name="14"><span class="lineNum">      14 </span>            : #include &lt;stack&gt;</a>
<a name="15"><span class="lineNum">      15 </span>            : #include &lt;memory&gt;</a>
<a name="16"><span class="lineNum">      16 </span>            : #include &lt;regex&gt;</a>
<a name="17"><span class="lineNum">      17 </span>            : #include &lt;csignal&gt;</a>
<a name="18"><span class="lineNum">      18 </span>            : #include &quot;median.h&quot;</a>
<a name="19"><span class="lineNum">      19 </span>            : #include &lt;utility&gt;</a>
<a name="20"><span class="lineNum">      20 </span>            : #include &lt;set&gt;</a>
<a name="21"><span class="lineNum">      21 </span>            : #include &lt;charconv&gt;</a>
<a name="22"><span class="lineNum">      22 </span>            : #include &lt;iterator&gt;</a>
<a name="23"><span class="lineNum">      23 </span>            : </a>
<a name="24"><span class="lineNum">      24 </span>            : // Undefine to capture stdout from running progarm</a>
<a name="25"><span class="lineNum">      25 </span>            : //#define CAPTURE_STDOUT</a>
<a name="26"><span class="lineNum">      26 </span>            : </a>
<a name="27"><span class="lineNum">      27 </span>            : #ifdef _MSC_VER</a>
<a name="28"><span class="lineNum">      28 </span>            : #define UNREACHABLE __assume(0)</a>
<a name="29"><span class="lineNum">      29 </span>            : #else</a>
<a name="30"><span class="lineNum">      30 </span>            : #define UNREACHABLE __builtin_unreachable()</a>
<a name="31"><span class="lineNum">      31 </span>            : #endif</a>
<a name="32"><span class="lineNum">      32 </span>            : </a>
<a name="33"><span class="lineNum">      33 </span>            : //thread_local std::random_device rd;  // Seed for the random number engine</a>
<a name="34"><span class="lineNum">      34 </span>            : /*thread_local */std::mt19937 gen/*(rd())*/; // Mersenne Twister engine seeded with `rd`</a>
<a name="35"><span class="lineNum">      35 </span>            : </a>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<a name="37"><span class="lineNum">      37 </span>            : /// &lt;summary&gt;</a>
<a name="38"><span class="lineNum">      38 </span>            : /// All random string generators</a>
<a name="39"><span class="lineNum">      39 </span>            : /// &lt;/summary&gt;</a>
<a name="40"><span class="lineNum">      40 </span>            : namespace generators {</a>
<a name="41"><span class="lineNum">      41 </span><span class="lineCov">          1 :     std::string generateRandomAlphaNum(std::size_t size) {</span></a>
<a name="42"><span class="lineNum">      42 </span><span class="lineCov">          1 :         constexpr char alphaNumerical[] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z' };</span></a>
<a name="43"><span class="lineNum">      43 </span><span class="lineCov">          1 :         std::uniform_int_distribution&lt;int&gt; dist(0, sizeof(alphaNumerical) - 1);</span></a>
<a name="44"><span class="lineNum">      44 </span>            : </a>
<a name="45"><span class="lineNum">      45 </span><span class="lineCov">          1 :         std::string randomString;</span></a>
<a name="46"><span class="lineNum">      46 </span><span class="lineCov">          1 :         randomString.reserve(size);</span></a>
<a name="47"><span class="lineNum">      47 </span>            : </a>
<a name="48"><span class="lineNum">      48 </span><span class="lineCov">         43 :         for (std::size_t i = 0; i &lt; size; ++i) {</span></a>
<a name="49"><span class="lineNum">      49 </span><span class="lineCov">         42 :             char tmp = alphaNumerical[dist(gen)];</span></a>
<a name="50"><span class="lineNum">      50 </span>            : </a>
<a name="51"><span class="lineNum">      51 </span><span class="lineCov">         42 :             randomString += tmp;</span></a>
<a name="52"><span class="lineNum">      52 </span>            :         }</a>
<a name="53"><span class="lineNum">      53 </span>            : </a>
<a name="54"><span class="lineNum">      54 </span><span class="lineCov">          2 :         return randomString;</span></a>
<a name="55"><span class="lineNum">      55 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="56"><span class="lineNum">      56 </span>            : </a>
<a name="57"><span class="lineNum">      57 </span><span class="lineCov">     844130 :     char generateRandomChar(uint8_t minChar = 32, uint8_t maxChar = 126) {</span></a>
<a name="58"><span class="lineNum">      58 </span><span class="lineCov">     844130 :         if (minChar &gt; maxChar) [[unlikely]]</span></a>
<a name="59"><span class="lineNum">      59 </span><span class="lineCov">          1 :             throw std::invalid_argument(&quot;min must be less than or equal to max&quot;);</span></a>
<a name="60"><span class="lineNum">      60 </span>            : </a>
<a name="61"><span class="lineNum">      61 </span><span class="lineCov">     844129 :         std::uniform_int_distribution&lt;int&gt; dist(minChar, maxChar);</span></a>
<a name="62"><span class="lineNum">      62 </span>            : </a>
<a name="63"><span class="lineNum">      63 </span><span class="lineCov">     844129 :         return dist(gen);</span></a>
<a name="64"><span class="lineNum">      64 </span>            :     }</a>
<a name="65"><span class="lineNum">      65 </span>            : </a>
<a name="66"><span class="lineNum">      66 </span><span class="lineCov">       1831 :     std::string generateRandomString(uint8_t minChar, uint8_t maxChar, std::size_t size) {</span></a>
<a name="67"><span class="lineNum">      67 </span><span class="lineCov">       1831 :         std::string randomString;</span></a>
<a name="68"><span class="lineNum">      68 </span><span class="lineCov">       1831 :         randomString.reserve(size);</span></a>
<a name="69"><span class="lineNum">      69 </span>            : </a>
<a name="70"><span class="lineNum">      70 </span><span class="lineCov">     845956 :         for (std::size_t i = 0; i &lt; size; ++i)</span></a>
<a name="71"><span class="lineNum">      71 </span><span class="lineCov">     844126 :             randomString += generateRandomChar(minChar, maxChar);</span></a>
<a name="72"><span class="lineNum">      72 </span>            : </a>
<a name="73"><span class="lineNum">      73 </span><span class="lineCov">       1830 :         return randomString;</span></a>
<a name="74"><span class="lineNum">      74 </span><span class="lineCov">          1 :     }</span></a>
<a name="75"><span class="lineNum">      75 </span>            : </a>
<a name="76"><span class="lineNum">      76 </span><span class="lineCov">       1609 :     std::string generateRandomNum(int min, int max) {</span></a>
<a name="77"><span class="lineNum">      77 </span><span class="lineCov">       1609 :         if (min &gt; max) [[unlikely]]</span></a>
<a name="78"><span class="lineNum">      78 </span><span class="lineCov">          1 :             throw std::invalid_argument(&quot;min must be less than or equal to max&quot;);</span></a>
<a name="79"><span class="lineNum">      79 </span>            : </a>
<a name="80"><span class="lineNum">      80 </span><span class="lineCov">       1608 :         std::uniform_int_distribution&lt;int&gt; dist(min, max);</span></a>
<a name="81"><span class="lineNum">      81 </span>            : </a>
<a name="82"><span class="lineNum">      82 </span><span class="lineCov">       3216 :         return std::to_string(dist(gen));</span></a>
<a name="83"><span class="lineNum">      83 </span>            :     }</a>
<a name="84"><span class="lineNum">      84 </span><span class="lineNoCov">          0 :     bool randomBool()</span></a>
<a name="85"><span class="lineNum">      85 </span>            :     {</a>
<a name="86"><span class="lineNum">      86 </span><span class="lineNoCov">          0 :         std::uniform_int_distribution&lt;int&gt; res(0, 1);</span></a>
<a name="87"><span class="lineNum">      87 </span><span class="lineNoCov">          0 :         return (bool)res(gen);</span></a>
<a name="88"><span class="lineNum">      88 </span>            :     }</a>
<a name="89"><span class="lineNum">      89 </span><span class="lineNoCov">          0 :     float randomFloat()</span></a>
<a name="90"><span class="lineNum">      90 </span>            :     {</a>
<a name="91"><span class="lineNum">      91 </span><span class="lineNoCov">          0 :         std::uniform_real_distribution&lt;float&gt; res(0, 1);</span></a>
<a name="92"><span class="lineNum">      92 </span><span class="lineNoCov">          0 :         return res(gen);</span></a>
<a name="93"><span class="lineNum">      93 </span>            :     }</a>
<a name="94"><span class="lineNum">      94 </span><span class="lineNoCov">          0 :     int randomInt(int max)</span></a>
<a name="95"><span class="lineNum">      95 </span>            :     {</a>
<a name="96"><span class="lineNum">      96 </span><span class="lineNoCov">          0 :         std::uniform_int_distribution&lt;int&gt; res(0, max-1);</span></a>
<a name="97"><span class="lineNum">      97 </span><span class="lineNoCov">          0 :         return res(gen);</span></a>
<a name="98"><span class="lineNum">      98 </span>            :     }</a>
<a name="99"><span class="lineNum">      99 </span><span class="lineNoCov">          0 :     char randomASCII()</span></a>
<a name="100"><span class="lineNum">     100 </span>            :     {</a>
<a name="101"><span class="lineNum">     101 </span><span class="lineNoCov">          0 :         std::uniform_int_distribution&lt;int&gt; res(32, 126);</span></a>
<a name="102"><span class="lineNum">     102 </span><span class="lineNoCov">          0 :         return res(gen);</span></a>
<a name="103"><span class="lineNum">     103 </span>            :     }</a>
<a name="104"><span class="lineNum">     104 </span><span class="lineNoCov">          0 :     char randomDigit()</span></a>
<a name="105"><span class="lineNum">     105 </span>            :     {</a>
<a name="106"><span class="lineNum">     106 </span><span class="lineNoCov">          0 :         std::uniform_int_distribution&lt;int&gt; res('0', '9');</span></a>
<a name="107"><span class="lineNum">     107 </span><span class="lineNoCov">          0 :         return res(gen);</span></a>
<a name="108"><span class="lineNum">     108 </span>            :     }</a>
<a name="109"><span class="lineNum">     109 </span>            : </a>
<a name="110"><span class="lineNum">     110 </span>            :     /// &lt;summary&gt;</a>
<a name="111"><span class="lineNum">     111 </span>            :     /// Provides random seeds for fuzzers. Sometimes generates string, sometimes numbers.</a>
<a name="112"><span class="lineNum">     112 </span>            :     /// &lt;/summary&gt;</a>
<a name="113"><span class="lineNum">     113 </span>            :     /// &lt;returns&gt;&lt;/returns&gt;</a>
<a name="114"><span class="lineNum">     114 </span><span class="lineCov">       3235 :     static std::string generateRandomInput()</span></a>
<a name="115"><span class="lineNum">     115 </span>            :     {</a>
<a name="116"><span class="lineNum">     116 </span><span class="lineCov">       3235 :         std::uniform_int_distribution&lt;int&gt; whichInput(0, 1);</span></a>
<a name="117"><span class="lineNum">     117 </span>            : </a>
<a name="118"><span class="lineNum">     118 </span><span class="lineCov">       3235 :         const size_t minSize = 1;</span></a>
<a name="119"><span class="lineNum">     119 </span><span class="lineCov">       3235 :         const size_t maxSize = 1024;</span></a>
<a name="120"><span class="lineNum">     120 </span>            : </a>
<a name="121"><span class="lineNum">     121 </span><span class="lineCov">       3235 :         std::uniform_int_distribution&lt;size_t&gt; dist(minSize, maxSize);</span></a>
<a name="122"><span class="lineNum">     122 </span>            : </a>
<a name="123"><span class="lineNum">     123 </span><span class="lineCov">       3235 :         switch (whichInput(gen))</span></a>
<a name="124"><span class="lineNum">     124 </span>            :         {</a>
<a name="125"><span class="lineNum">     125 </span><span class="lineCov">       1628 :         case 0:</span></a>
<a name="126"><span class="lineNum">     126 </span><span class="lineCov">       1628 :             return generators::generateRandomString(33, 126, dist(gen));</span></a>
<a name="127"><span class="lineNum">     127 </span><span class="lineCov">       1607 :         case 1:</span></a>
<a name="128"><span class="lineNum">     128 </span><span class="lineCov">       1607 :             return generators::generateRandomNum(1, 1000000);</span></a>
<a name="129"><span class="lineNum">     129 </span><span class="lineNoCov">          0 :         default:</span></a>
<a name="130"><span class="lineNum">     130 </span><span class="lineNoCov">          0 :             UNREACHABLE;</span></a>
<a name="131"><span class="lineNum">     131 </span>            :         }</a>
<a name="132"><span class="lineNum">     132 </span>            :     }</a>
<a name="133"><span class="lineNum">     133 </span>            : }</a>
<a name="134"><span class="lineNum">     134 </span>            : </a>
<a name="135"><span class="lineNum">     135 </span><span class="lineCov">        518 : bool isJsonAllowedOrEscapeable(char c)</span></a>
<a name="136"><span class="lineNum">     136 </span>            : {</a>
<a name="137"><span class="lineNum">     137 </span><span class="lineCov">        518 :     unsigned char uchar = static_cast&lt;unsigned char&gt;(c);</span></a>
<a name="138"><span class="lineNum">     138 </span><span class="lineCov">        518 :     return !(uchar &gt; 126 || uchar &lt; 8 || uchar == 11 || (uchar &lt; 32 &amp;&amp; uchar &gt; 13));</span></a>
<a name="139"><span class="lineNum">     139 </span>            : }</a>
<a name="140"><span class="lineNum">     140 </span>            : </a>
<a name="141"><span class="lineNum">     141 </span>            : /// &lt;summary&gt;</a>
<a name="142"><span class="lineNum">     142 </span>            : /// Escape a character as a unicode symbol (for unsupported characters)</a>
<a name="143"><span class="lineNum">     143 </span>            : /// &lt;/summary&gt;</a>
<a name="144"><span class="lineNum">     144 </span>            : /// &lt;param name=&quot;out&quot;&gt;Output stream to escape to&lt;/param&gt;</a>
<a name="145"><span class="lineNum">     145 </span>            : /// &lt;param name=&quot;c&quot;&gt;Char to escape&lt;/param&gt;</a>
<a name="146"><span class="lineNum">     146 </span>            : /// &lt;returns&gt;Output stream from argument&lt;/returns&gt;</a>
<a name="147"><span class="lineNum">     147 </span><span class="lineCov">        156 : static std::ostream&amp; escapeUnicode(std::ostream&amp; out, char c)</span></a>
<a name="148"><span class="lineNum">     148 </span>            : {</a>
<a name="149"><span class="lineNum">     149 </span>            :     // save default formatting</a>
<a name="150"><span class="lineNum">     150 </span><span class="lineCov">        156 :     std::ios init(NULL);</span></a>
<a name="151"><span class="lineNum">     151 </span><span class="lineCov">        156 :     init.copyfmt(out);</span></a>
<a name="152"><span class="lineNum">     152 </span>            : </a>
<a name="153"><span class="lineNum">     153 </span><span class="lineCov">        156 :     out &lt;&lt; &quot;\\u00&quot;</span></a>
<a name="154"><span class="lineNum">     154 </span><span class="lineCov">        156 :         &lt;&lt; std::hex &lt;&lt; std::uppercase // Use uppercase for letters in hex</span></a>
<a name="155"><span class="lineNum">     155 </span><span class="lineCov">        156 :         &lt;&lt; std::setw(2) &lt;&lt; std::setfill('0') // Ensures 2-digit output</span></a>
<a name="156"><span class="lineNum">     156 </span><span class="lineCov">        156 :         &lt;&lt; static_cast&lt;int&gt;(static_cast&lt;unsigned char&gt;(c));</span></a>
<a name="157"><span class="lineNum">     157 </span>            : </a>
<a name="158"><span class="lineNum">     158 </span><span class="lineCov">        156 :     out.copyfmt(init);</span></a>
<a name="159"><span class="lineNum">     159 </span>            : </a>
<a name="160"><span class="lineNum">     160 </span><span class="lineCov">        156 :     return out;</span></a>
<a name="161"><span class="lineNum">     161 </span><span class="lineCov">        156 : }</span></a>
<a name="162"><span class="lineNum">     162 </span>            : </a>
<a name="163"><span class="lineNum">     163 </span>            : /// &lt;summary&gt;</a>
<a name="164"><span class="lineNum">     164 </span>            : /// Escape a char to JSON format</a>
<a name="165"><span class="lineNum">     165 </span>            : /// &lt;/summary&gt;</a>
<a name="166"><span class="lineNum">     166 </span>            : /// &lt;param name=&quot;out&quot;&gt;Output stream to escape to&lt;/param&gt;</a>
<a name="167"><span class="lineNum">     167 </span>            : /// &lt;param name=&quot;c&quot;&gt;Character to escape&lt;/param&gt;</a>
<a name="168"><span class="lineNum">     168 </span>            : /// &lt;returns&gt;Output stream from argument&lt;/returns&gt;</a>
<a name="169"><span class="lineNum">     169 </span><span class="lineCov">        312 : static std::ostream&amp; escape(std::ostream&amp; out, char c)</span></a>
<a name="170"><span class="lineNum">     170 </span>            : {</a>
<a name="171"><span class="lineNum">     171 </span><span class="lineCov">        312 :     if(!isJsonAllowedOrEscapeable(c))</span></a>
<a name="172"><span class="lineNum">     172 </span><span class="lineCov">        156 :         return escapeUnicode(out, c);</span></a>
<a name="173"><span class="lineNum">     173 </span>            : </a>
<a name="174"><span class="lineNum">     174 </span><span class="lineCov">        156 :     switch (c)</span></a>
<a name="175"><span class="lineNum">     175 </span>            :     {</a>
<a name="176"><span class="lineNum">     176 </span><span class="lineCov">          1 :     case '\b':</span></a>
<a name="177"><span class="lineNum">     177 </span><span class="lineCov">          1 :         out &lt;&lt; &quot;\\b&quot;;</span></a>
<a name="178"><span class="lineNum">     178 </span><span class="lineCov">          1 :         break;</span></a>
<a name="179"><span class="lineNum">     179 </span><span class="lineCov">          1 :     case '\t':</span></a>
<a name="180"><span class="lineNum">     180 </span><span class="lineCov">          1 :         out &lt;&lt; &quot;\\t&quot;;</span></a>
<a name="181"><span class="lineNum">     181 </span><span class="lineCov">          1 :         break;</span></a>
<a name="182"><span class="lineNum">     182 </span><span class="lineCov">          1 :     case '\n':</span></a>
<a name="183"><span class="lineNum">     183 </span><span class="lineCov">          1 :         out &lt;&lt; &quot;\\n&quot;;</span></a>
<a name="184"><span class="lineNum">     184 </span><span class="lineCov">          1 :         break;</span></a>
<a name="185"><span class="lineNum">     185 </span><span class="lineCov">          1 :     case '\f':</span></a>
<a name="186"><span class="lineNum">     186 </span><span class="lineCov">          1 :         out &lt;&lt; &quot;\\f&quot;;</span></a>
<a name="187"><span class="lineNum">     187 </span><span class="lineCov">          1 :         break;</span></a>
<a name="188"><span class="lineNum">     188 </span><span class="lineCov">          1 :     case '\r':</span></a>
<a name="189"><span class="lineNum">     189 </span><span class="lineCov">          1 :         out &lt;&lt; &quot;\\r&quot;;</span></a>
<a name="190"><span class="lineNum">     190 </span><span class="lineCov">          1 :         break;</span></a>
<a name="191"><span class="lineNum">     191 </span><span class="lineCov">          2 :     case '\\':</span></a>
<a name="192"><span class="lineNum">     192 </span>            :     case '&quot;':</a>
<a name="193"><span class="lineNum">     193 </span><span class="lineCov">          2 :         out &lt;&lt; '\\';</span></a>
<a name="194"><span class="lineNum">     194 </span>            :         [[fallthrough]];</a>
<a name="195"><span class="lineNum">     195 </span><span class="lineCov">        151 :     default:</span></a>
<a name="196"><span class="lineNum">     196 </span><span class="lineCov">        151 :         out &lt;&lt; c;</span></a>
<a name="197"><span class="lineNum">     197 </span><span class="lineCov">        151 :         break;</span></a>
<a name="198"><span class="lineNum">     198 </span>            :     }</a>
<a name="199"><span class="lineNum">     199 </span><span class="lineCov">        156 :     return out;</span></a>
<a name="200"><span class="lineNum">     200 </span>            : }</a>
<a name="201"><span class="lineNum">     201 </span>            : </a>
<a name="202"><span class="lineNum">     202 </span>            : /// &lt;summary&gt;</a>
<a name="203"><span class="lineNum">     203 </span>            : /// Escape a string to JSON format</a>
<a name="204"><span class="lineNum">     204 </span>            : /// &lt;/summary&gt;</a>
<a name="205"><span class="lineNum">     205 </span>            : /// &lt;param name=&quot;out&quot;&gt;Output stream to escape to&lt;/param&gt;</a>
<a name="206"><span class="lineNum">     206 </span>            : /// &lt;param name=&quot;str&quot;&gt;String to escape&lt;/param&gt;</a>
<a name="207"><span class="lineNum">     207 </span>            : /// &lt;returns&gt;Output stream from argument&lt;/returns&gt;</a>
<a name="208"><span class="lineNum">     208 </span><span class="lineCov">         11 : static std::ostream&amp; escape(std::ostream&amp; out, const std::string_view&amp; str)</span></a>
<a name="209"><span class="lineNum">     209 </span>            : {</a>
<a name="210"><span class="lineNum">     210 </span><span class="lineCov">         67 :     for (const auto&amp; c : str)</span></a>
<a name="211"><span class="lineNum">     211 </span>            :     {</a>
<a name="212"><span class="lineNum">     212 </span><span class="lineCov">         56 :         escape(out, c);</span></a>
<a name="213"><span class="lineNum">     213 </span>            :     }</a>
<a name="214"><span class="lineNum">     214 </span><span class="lineCov">         11 :     return out;</span></a>
<a name="215"><span class="lineNum">     215 </span>            : }</a>
<a name="216"><span class="lineNum">     216 </span>            : </a>
<a name="217"><span class="lineNum">     217 </span>            : /// &lt;summary&gt;</a>
<a name="218"><span class="lineNum">     218 </span>            : /// Mutators that can change existing strings</a>
<a name="219"><span class="lineNum">     219 </span>            : /// &lt;/summary&gt;</a>
<a name="220"><span class="lineNum">     220 </span>            : namespace mutators {</a>
<a name="221"><span class="lineNum">     221 </span>            :     /// &lt;summary&gt;</a>
<a name="222"><span class="lineNum">     222 </span>            :     /// Deletes block of random size from random location at the string</a>
<a name="223"><span class="lineNum">     223 </span>            :     /// &lt;/summary&gt;</a>
<a name="224"><span class="lineNum">     224 </span><span class="lineCov">          1 :     void deleteBlock(std::string&amp; str)</span></a>
<a name="225"><span class="lineNum">     225 </span>            :     {</a>
<a name="226"><span class="lineNum">     226 </span><span class="lineCov">          1 :         if (str.size() &lt;= 1) [[unlikely]]</span></a>
<a name="227"><span class="lineNum">     227 </span><span class="lineNoCov">          0 :             return;</span></a>
<a name="228"><span class="lineNum">     228 </span>            : </a>
<a name="229"><span class="lineNum">     229 </span><span class="lineCov">          1 :         std::exponential_distribution&lt;float&gt; distLen(1.0);</span></a>
<a name="230"><span class="lineNum">     230 </span><span class="lineCov">          1 :         int blockSize = 1 + round(distLen(gen));</span></a>
<a name="231"><span class="lineNum">     231 </span>            : </a>
<a name="232"><span class="lineNum">     232 </span><span class="lineCov">          1 :         if ((int)str.size() - blockSize &lt;= 0) [[unlikely]]</span></a>
<a name="233"><span class="lineNum">     233 </span><span class="lineNoCov">          0 :             return;//Don't generate empty strings</span></a>
<a name="234"><span class="lineNum">     234 </span>            : </a>
<a name="235"><span class="lineNum">     235 </span><span class="lineCov">          1 :         std::uniform_int_distribution&lt;int&gt; distStart(0, str.size() - 2);</span></a>
<a name="236"><span class="lineNum">     236 </span><span class="lineCov">          1 :         int start = distStart(gen);</span></a>
<a name="237"><span class="lineNum">     237 </span>            : </a>
<a name="238"><span class="lineNum">     238 </span><span class="lineCov">          1 :         blockSize = std::min(blockSize, (int)str.size() - start);</span></a>
<a name="239"><span class="lineNum">     239 </span>            : </a>
<a name="240"><span class="lineNum">     240 </span><span class="lineCov">          1 :         str.erase(start, blockSize);</span></a>
<a name="241"><span class="lineNum">     241 </span>            :     }</a>
<a name="242"><span class="lineNum">     242 </span>            : </a>
<a name="243"><span class="lineNum">     243 </span>            :     /// &lt;summary&gt;</a>
<a name="244"><span class="lineNum">     244 </span>            :     /// Inserts new block of random size to random location at the string</a>
<a name="245"><span class="lineNum">     245 </span>            :     /// &lt;/summary&gt;</a>
<a name="246"><span class="lineNum">     246 </span><span class="lineCov">        101 :     void insertBlock(std::string&amp; input)</span></a>
<a name="247"><span class="lineNum">     247 </span>            :     {</a>
<a name="248"><span class="lineNum">     248 </span><span class="lineCov">        101 :         std::exponential_distribution&lt;float&gt; distLen(1.0);</span></a>
<a name="249"><span class="lineNum">     249 </span><span class="lineCov">        101 :         size_t blockLen = 1 + round(distLen(gen));</span></a>
<a name="250"><span class="lineNum">     250 </span><span class="lineCov">        101 :         std::uniform_int_distribution&lt;size_t&gt; distStart(0, input.size());</span></a>
<a name="251"><span class="lineNum">     251 </span><span class="lineCov">        101 :         size_t blockStart = distStart(gen);</span></a>
<a name="252"><span class="lineNum">     252 </span>            : </a>
<a name="253"><span class="lineNum">     253 </span><span class="lineCov">        101 :         input.insert(blockStart, generators::generateRandomString(32, 126, blockLen));</span></a>
<a name="254"><span class="lineNum">     254 </span><span class="lineCov">        101 :     }</span></a>
<a name="255"><span class="lineNum">     255 </span>            : </a>
<a name="256"><span class="lineNum">     256 </span>            :     /// &lt;summary&gt;</a>
<a name="257"><span class="lineNum">     257 </span>            :     /// Insert random digit somewhere random in the string</a>
<a name="258"><span class="lineNum">     258 </span>            :     /// &lt;/summary&gt;</a>
<a name="259"><span class="lineNum">     259 </span><span class="lineCov">          1 :     void insertDigit(std::string&amp; input)</span></a>
<a name="260"><span class="lineNum">     260 </span>            :     {</a>
<a name="261"><span class="lineNum">     261 </span><span class="lineCov">          1 :         std::uniform_int_distribution&lt;int&gt; distChar(0, 9);</span></a>
<a name="262"><span class="lineNum">     262 </span>            : </a>
<a name="263"><span class="lineNum">     263 </span><span class="lineCov">          1 :         std::uniform_int_distribution&lt;size_t&gt; distStart(0, input.size());</span></a>
<a name="264"><span class="lineNum">     264 </span><span class="lineCov">          1 :         size_t blockStart = distStart(gen);</span></a>
<a name="265"><span class="lineNum">     265 </span>            : </a>
<a name="266"><span class="lineNum">     266 </span><span class="lineCov">          1 :         input.insert(input.begin() + blockStart, (char)(distChar(gen) + '0'));</span></a>
<a name="267"><span class="lineNum">     267 </span><span class="lineCov">          1 :     }</span></a>
<a name="268"><span class="lineNum">     268 </span>            : </a>
<a name="269"><span class="lineNum">     269 </span>            :     /// &lt;summary&gt;</a>
<a name="270"><span class="lineNum">     270 </span>            :     /// Insert '\n' somewhere random in the string</a>
<a name="271"><span class="lineNum">     271 </span>            :     /// &lt;/summary&gt;</a>
<a name="272"><span class="lineNum">     272 </span><span class="lineCov">          1 :     void insertNewline(std::string&amp; input)</span></a>
<a name="273"><span class="lineNum">     273 </span>            :     {</a>
<a name="274"><span class="lineNum">     274 </span><span class="lineCov">          1 :         std::uniform_int_distribution&lt;size_t&gt; distStart(0, input.size());</span></a>
<a name="275"><span class="lineNum">     275 </span><span class="lineCov">          1 :         size_t blockStart = distStart(gen);</span></a>
<a name="276"><span class="lineNum">     276 </span>            : </a>
<a name="277"><span class="lineNum">     277 </span><span class="lineCov">          1 :         input.insert(input.begin() + blockStart, '\n');</span></a>
<a name="278"><span class="lineNum">     278 </span><span class="lineCov">          1 :     }</span></a>
<a name="279"><span class="lineNum">     279 </span>            : </a>
<a name="280"><span class="lineNum">     280 </span>            :     /// &lt;summary&gt;</a>
<a name="281"><span class="lineNum">     281 </span>            :     /// Insert '\n' at the end of the string</a>
<a name="282"><span class="lineNum">     282 </span>            :     /// &lt;/summary&gt;</a>
<a name="283"><span class="lineNum">     283 </span><span class="lineNoCov">          0 :     void appendNewline(std::string&amp; input)</span></a>
<a name="284"><span class="lineNum">     284 </span>            :     {</a>
<a name="285"><span class="lineNum">     285 </span><span class="lineNoCov">          0 :         input += '\n';</span></a>
<a name="286"><span class="lineNum">     286 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="287"><span class="lineNum">     287 </span>            : </a>
<a name="288"><span class="lineNum">     288 </span>            :     /// &lt;summary&gt;</a>
<a name="289"><span class="lineNum">     289 </span>            :     /// Join two strings together</a>
<a name="290"><span class="lineNum">     290 </span>            :     /// &lt;/summary&gt;</a>
<a name="291"><span class="lineNum">     291 </span>            :     /// &lt;param name=&quot;input&quot;&gt;First string, will increase in size&lt;/param&gt;</a>
<a name="292"><span class="lineNum">     292 </span>            :     /// &lt;param name=&quot;input2&quot;&gt;Second string, will be added to the first one&lt;/param&gt;</a>
<a name="293"><span class="lineNum">     293 </span><span class="lineCov">          1 :     void concat(std::string&amp; input, const std::string&amp; input2)</span></a>
<a name="294"><span class="lineNum">     294 </span>            :     {</a>
<a name="295"><span class="lineNum">     295 </span><span class="lineCov">          1 :         input.reserve(input.size() + input2.size());</span></a>
<a name="296"><span class="lineNum">     296 </span><span class="lineCov">          1 :         input += input2;</span></a>
<a name="297"><span class="lineNum">     297 </span><span class="lineCov">          1 :     }</span></a>
<a name="298"><span class="lineNum">     298 </span>            : </a>
<a name="299"><span class="lineNum">     299 </span>            :     /// &lt;summary&gt;</a>
<a name="300"><span class="lineNum">     300 </span>            :     /// If seed is a number, slightly change it</a>
<a name="301"><span class="lineNum">     301 </span>            :     /// &lt;/summary&gt;</a>
<a name="302"><span class="lineNum">     302 </span><span class="lineCov">          1 :     void changeNum(std::string&amp; input)</span></a>
<a name="303"><span class="lineNum">     303 </span>            :     {</a>
<a name="304"><span class="lineNum">     304 </span><span class="lineCov">          1 :         if (input.size() &gt;= 19) // Cannot work with too long strings</span></a>
<a name="305"><span class="lineNum">     305 </span><span class="lineNoCov">          0 :             return;</span></a>
<a name="306"><span class="lineNum">     306 </span>            : </a>
<a name="307"><span class="lineNum">     307 </span><span class="lineCov">          3 :         for (const auto&amp; c : input)</span></a>
<a name="308"><span class="lineNum">     308 </span>            :         {</a>
<a name="309"><span class="lineNum">     309 </span><span class="lineCov">          2 :             if (!isdigit(c)) // Only change strings that are fully numeric</span></a>
<a name="310"><span class="lineNum">     310 </span><span class="lineNoCov">          0 :                 return;</span></a>
<a name="311"><span class="lineNum">     311 </span>            :         }</a>
<a name="312"><span class="lineNum">     312 </span><span class="lineCov">          1 :         auto num = std::stoll(input);</span></a>
<a name="313"><span class="lineNum">     313 </span>            : </a>
<a name="314"><span class="lineNum">     314 </span><span class="lineCov">          1 :         std::exponential_distribution&lt;float&gt; distLen(0.25);</span></a>
<a name="315"><span class="lineNum">     315 </span>            : </a>
<a name="316"><span class="lineNum">     316 </span><span class="lineCov">          1 :         std::uniform_int_distribution&lt;int&gt; negative(0, 1);</span></a>
<a name="317"><span class="lineNum">     317 </span>            : </a>
<a name="318"><span class="lineNum">     318 </span><span class="lineCov">          1 :         int val = 1 + round(distLen(gen));</span></a>
<a name="319"><span class="lineNum">     319 </span><span class="lineCov">          1 :         val *= 2 * negative(gen) - 1;</span></a>
<a name="320"><span class="lineNum">     320 </span>            : </a>
<a name="321"><span class="lineNum">     321 </span><span class="lineCov">          1 :         num += val;</span></a>
<a name="322"><span class="lineNum">     322 </span>            : </a>
<a name="323"><span class="lineNum">     323 </span><span class="lineCov">          1 :         input = std::to_string(num);</span></a>
<a name="324"><span class="lineNum">     324 </span>            :     }</a>
<a name="325"><span class="lineNum">     325 </span>            : </a>
<a name="326"><span class="lineNum">     326 </span>            :     /// &lt;summary&gt;</a>
<a name="327"><span class="lineNum">     327 </span>            :     /// Flip random bit in random byte in a string, so that it remains an ASCII character</a>
<a name="328"><span class="lineNum">     328 </span>            :     /// &lt;/summary&gt;</a>
<a name="329"><span class="lineNum">     329 </span><span class="lineCov">         45 :     void flipBitASCII(std::string&amp; input)</span></a>
<a name="330"><span class="lineNum">     330 </span>            :     {</a>
<a name="331"><span class="lineNum">     331 </span><span class="lineCov">         45 :         std::uniform_int_distribution&lt;size_t&gt; distPos(0, input.size() - 1);</span></a>
<a name="332"><span class="lineNum">     332 </span><span class="lineCov">         45 :         std::uniform_int_distribution&lt;int&gt; distBit(0, 6);</span></a>
<a name="333"><span class="lineNum">     333 </span>            : </a>
<a name="334"><span class="lineNum">     334 </span><span class="lineCov">         45 :         char&amp; charToChange = input[distPos(gen)];</span></a>
<a name="335"><span class="lineNum">     335 </span>            : </a>
<a name="336"><span class="lineNum">     336 </span><span class="lineCov">         45 :         charToChange ^= (1 &lt;&lt; distBit(gen));</span></a>
<a name="337"><span class="lineNum">     337 </span>            : </a>
<a name="338"><span class="lineNum">     338 </span><span class="lineCov">         45 :         if (!isJsonAllowedOrEscapeable(charToChange)) [[unlikely]] // The change resulted in non-printable ASCI</span></a>
<a name="339"><span class="lineNum">     339 </span><span class="lineCov">          4 :             charToChange = generators::generateRandomChar();</span></a>
<a name="340"><span class="lineNum">     340 </span><span class="lineCov">         45 :     }</span></a>
<a name="341"><span class="lineNum">     341 </span>            : </a>
<a name="342"><span class="lineNum">     342 </span>            :     /// &lt;summary&gt;</a>
<a name="343"><span class="lineNum">     343 </span>            :     /// Add random number to random byte in a string, so that it remains an ASCII character</a>
<a name="344"><span class="lineNum">     344 </span>            :     /// &lt;/summary&gt;</a>
<a name="345"><span class="lineNum">     345 </span><span class="lineCov">          1 :     void addASCII(std::string&amp; input)</span></a>
<a name="346"><span class="lineNum">     346 </span>            :     {</a>
<a name="347"><span class="lineNum">     347 </span><span class="lineCov">          1 :         std::uniform_int_distribution&lt;size_t&gt; distPos(0, input.size() - 1);</span></a>
<a name="348"><span class="lineNum">     348 </span><span class="lineCov">          1 :         std::exponential_distribution&lt;float&gt; distVal(1);</span></a>
<a name="349"><span class="lineNum">     349 </span>            : </a>
<a name="350"><span class="lineNum">     350 </span><span class="lineCov">          1 :         std::uniform_int_distribution&lt;int&gt; negative(0, 1);</span></a>
<a name="351"><span class="lineNum">     351 </span>            : </a>
<a name="352"><span class="lineNum">     352 </span><span class="lineCov">          1 :         int val = 1 + round(distVal(gen));</span></a>
<a name="353"><span class="lineNum">     353 </span><span class="lineCov">          1 :         val *= 2 * negative(gen) - 1;</span></a>
<a name="354"><span class="lineNum">     354 </span>            : </a>
<a name="355"><span class="lineNum">     355 </span><span class="lineCov">          1 :         char&amp; charToChange = input[distPos(gen)];</span></a>
<a name="356"><span class="lineNum">     356 </span>            : </a>
<a name="357"><span class="lineNum">     357 </span><span class="lineCov">          1 :         charToChange += val;</span></a>
<a name="358"><span class="lineNum">     358 </span>            : </a>
<a name="359"><span class="lineNum">     359 </span><span class="lineCov">          1 :         if (!isJsonAllowedOrEscapeable(charToChange)) [[unlikely]] // The change resulted in non-printable ASCI</span></a>
<a name="360"><span class="lineNum">     360 </span><span class="lineNoCov">          0 :             charToChange = generators::generateRandomChar();</span></a>
<a name="361"><span class="lineNum">     361 </span><span class="lineCov">          1 :     }</span></a>
<a name="362"><span class="lineNum">     362 </span>            : </a>
<a name="363"><span class="lineNum">     363 </span>            :     /// &lt;summary&gt;</a>
<a name="364"><span class="lineNum">     364 </span>            :     /// Selects random mutator and applies the mutation</a>
<a name="365"><span class="lineNum">     365 </span>            :     /// &lt;/summary&gt;</a>
<a name="366"><span class="lineNum">     366 </span>            :     /// &lt;param name=&quot;input1&quot;&gt;Mutation will be applied to this string&lt;/param&gt;</a>
<a name="367"><span class="lineNum">     367 </span>            :     /// &lt;param name=&quot;input2&quot;&gt;Some mutators will use this second string to read from&lt;/param&gt;</a>
<a name="368"><span class="lineNum">     368 </span><span class="lineNoCov">          0 :     void randomMutant(std::string&amp; input)</span></a>
<a name="369"><span class="lineNum">     369 </span>            :     {</a>
<a name="370"><span class="lineNum">     370 </span><span class="lineNoCov">          0 :         switch (generators::randomInt(6))</span></a>
<a name="371"><span class="lineNum">     371 </span>            :         {</a>
<a name="372"><span class="lineNum">     372 </span><span class="lineNoCov">          0 :         case 0:</span></a>
<a name="373"><span class="lineNum">     373 </span><span class="lineNoCov">          0 :             return deleteBlock(input);</span></a>
<a name="374"><span class="lineNum">     374 </span><span class="lineNoCov">          0 :         case 1:</span></a>
<a name="375"><span class="lineNum">     375 </span><span class="lineNoCov">          0 :             return insertBlock(input);</span></a>
<a name="376"><span class="lineNum">     376 </span><span class="lineNoCov">          0 :         case 2:</span></a>
<a name="377"><span class="lineNum">     377 </span><span class="lineNoCov">          0 :             return changeNum(input);</span></a>
<a name="378"><span class="lineNum">     378 </span><span class="lineNoCov">          0 :         case 3:</span></a>
<a name="379"><span class="lineNum">     379 </span><span class="lineNoCov">          0 :             return insertDigit(input);</span></a>
<a name="380"><span class="lineNum">     380 </span><span class="lineNoCov">          0 :         case 4:</span></a>
<a name="381"><span class="lineNum">     381 </span><span class="lineNoCov">          0 :             return addASCII(input);</span></a>
<a name="382"><span class="lineNum">     382 </span><span class="lineNoCov">          0 :         case 5:</span></a>
<a name="383"><span class="lineNum">     383 </span><span class="lineNoCov">          0 :             return flipBitASCII(input);</span></a>
<a name="384"><span class="lineNum">     384 </span><span class="lineNoCov">          0 :         default:</span></a>
<a name="385"><span class="lineNum">     385 </span><span class="lineNoCov">          0 :             UNREACHABLE;</span></a>
<a name="386"><span class="lineNum">     386 </span>            :         }</a>
<a name="387"><span class="lineNum">     387 </span>            :     }</a>
<a name="388"><span class="lineNum">     388 </span>            : </a>
<a name="389"><span class="lineNum">     389 </span>            :     /// &lt;summary&gt;</a>
<a name="390"><span class="lineNum">     390 </span>            :     /// Perform several random mutations</a>
<a name="391"><span class="lineNum">     391 </span>            :     /// &lt;/summary&gt;</a>
<a name="392"><span class="lineNum">     392 </span>            :     /// &lt;param name=&quot;input1&quot;&gt;String to mutate&lt;/param&gt;</a>
<a name="393"><span class="lineNum">     393 </span><span class="lineNoCov">          0 :     void randomNumberOfRandomMutants(std::string&amp; input)</span></a>
<a name="394"><span class="lineNum">     394 </span>            :     {</a>
<a name="395"><span class="lineNum">     395 </span><span class="lineNoCov">          0 :         std::exponential_distribution&lt;float&gt; distVal(1);</span></a>
<a name="396"><span class="lineNum">     396 </span>            : </a>
<a name="397"><span class="lineNum">     397 </span><span class="lineNoCov">          0 :         for (size_t i = 1 + round(distVal(gen)); i != 0; i--)</span></a>
<a name="398"><span class="lineNum">     398 </span><span class="lineNoCov">          0 :             randomMutant(input);</span></a>
<a name="399"><span class="lineNum">     399 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="400"><span class="lineNum">     400 </span>            : }</a>
<a name="401"><span class="lineNum">     401 </span>            : </a>
<a name="402"><span class="lineNum">     402 </span>            : static size_t currentAsanOffset = 0; // Workaround for coverage tool skewing the line numbers</a>
<a name="403"><span class="lineNum">     403 </span>            : static const std::regex errorTypeRegex(&quot;ERROR: AddressSanitizer: (.*) on address&quot;);</a>
<a name="404"><span class="lineNum">     404 </span>            : static const std::regex locationRegex(&quot;(main.c):(\\d+)&quot;);</a>
<a name="405"><span class="lineNum">     405 </span>            : </a>
<a name="406"><span class="lineNum">     406 </span>            : /// &lt;summary&gt;</a>
<a name="407"><span class="lineNum">     407 </span>            : /// Represents the base class for black/grey box fuzzing</a>
<a name="408"><span class="lineNum">     408 </span>            : /// &lt;/summary&gt;</a>
<a name="409"><span class="lineNum">     409 </span>            : struct fuzzer {</a>
<a name="410"><span class="lineNum">     410 </span>            :     std::atomic&lt;size_t&gt; nb_before_min = 0;</a>
<a name="411"><span class="lineNum">     411 </span>            :     std::atomic&lt;size_t&gt; nb_failed_runs = 0;</a>
<a name="412"><span class="lineNum">     412 </span>            :     std::atomic&lt;size_t&gt; nb_hanged_runs = 0;</a>
<a name="413"><span class="lineNum">     413 </span>            : </a>
<a name="414"><span class="lineNum">     414 </span>            :     StatisticsMemory&lt;double&gt; statisticsExecution;</a>
<a name="415"><span class="lineNum">     415 </span>            :     StatisticsMemory&lt;double&gt; statisticsMinimization;</a>
<a name="416"><span class="lineNum">     416 </span>            :     StatisticsMemory&lt;uint32_t&gt; statisticsMinimizationSteps;</a>
<a name="417"><span class="lineNum">     417 </span>            : </a>
<a name="418"><span class="lineNum">     418 </span>            :     /// &lt;summary&gt;</a>
<a name="419"><span class="lineNum">     419 </span>            :     /// This bool will be turned to false when fuzzer should terminate</a>
<a name="420"><span class="lineNum">     420 </span>            :     /// &lt;/summary&gt;</a>
<a name="421"><span class="lineNum">     421 </span>            :     std::atomic&lt;bool&gt; keepRunning = true;</a>
<a name="422"><span class="lineNum">     422 </span>            : </a>
<a name="423"><span class="lineNum">     423 </span>            :     /// &lt;summary&gt;</a>
<a name="424"><span class="lineNum">     424 </span>            :     /// Result of one execution</a>
<a name="425"><span class="lineNum">     425 </span>            :     /// &lt;/summary&gt;</a>
<a name="426"><span class="lineNum">     426 </span>            :     struct ExecutionResult {</a>
<a name="427"><span class="lineNum">     427 </span>            :         int return_code;</a>
<a name="428"><span class="lineNum">     428 </span>            : #ifdef CAPTURE_STDOUT</a>
<a name="429"><span class="lineNum">     429 </span>            :         std::string stdout_output;</a>
<a name="430"><span class="lineNum">     430 </span>            : #endif</a>
<a name="431"><span class="lineNum">     431 </span>            :         std::string stderr_output;</a>
<a name="432"><span class="lineNum">     432 </span>            :         bool timed_out;</a>
<a name="433"><span class="lineNum">     433 </span>            :         std::chrono::duration&lt;double, std::milli&gt; execution_time;</a>
<a name="434"><span class="lineNum">     434 </span>            : </a>
<a name="435"><span class="lineNum">     435 </span>            :         bool operator==(const ExecutionResult&amp;) const = default;</a>
<a name="436"><span class="lineNum">     436 </span>            :     };</a>
<a name="437"><span class="lineNum">     437 </span>            : </a>
<a name="438"><span class="lineNum">     438 </span>            :     /// &lt;summary&gt;</a>
<a name="439"><span class="lineNum">     439 </span>            :     /// Base class for execution inputs</a>
<a name="440"><span class="lineNum">     440 </span>            :     /// &lt;/summary&gt;</a>
<a name="441"><span class="lineNum">     441 </span>            :     struct ExecutionInput</a>
<a name="442"><span class="lineNum">     442 </span>            :     {</a>
<a name="443"><span class="lineNum">     443 </span><span class="lineCov">         12 :         ExecutionInput(std::filesystem::path executablePath, std::chrono::milliseconds timeout) : executablePath(std::move(executablePath)), timeout(std::move(timeout)) {}</span></a>
<a name="444"><span class="lineNum">     444 </span>            : </a>
<a name="445"><span class="lineNum">     445 </span>            :         virtual std::vector&lt;std::string&gt; getArguments() const = 0;</a>
<a name="446"><span class="lineNum">     446 </span>            :         virtual std::string_view getCin() const = 0;</a>
<a name="447"><span class="lineNum">     447 </span>            : </a>
<a name="448"><span class="lineNum">     448 </span>            :         virtual void setInput(const std::string_view&amp; input) = 0;</a>
<a name="449"><span class="lineNum">     449 </span>            : </a>
<a name="450"><span class="lineNum">     450 </span>            :         const std::filesystem::path executablePath;</a>
<a name="451"><span class="lineNum">     451 </span>            :         const std::chrono::milliseconds timeout;</a>
<a name="452"><span class="lineNum">     452 </span>            : </a>
<a name="453"><span class="lineNum">     453 </span><span class="lineCov">         12 :         virtual ~ExecutionInput() = default;</span></a>
<a name="454"><span class="lineNum">     454 </span>            :     };</a>
<a name="455"><span class="lineNum">     455 </span>            : </a>
<a name="456"><span class="lineNum">     456 </span>            :     /// &lt;summary&gt;</a>
<a name="457"><span class="lineNum">     457 </span>            :     /// Execution input in form of a file content</a>
<a name="458"><span class="lineNum">     458 </span>            :     /// &lt;/summary&gt;</a>
<a name="459"><span class="lineNum">     459 </span>            :     struct FileInput final : public ExecutionInput</a>
<a name="460"><span class="lineNum">     460 </span>            :     {</a>
<a name="461"><span class="lineNum">     461 </span><span class="lineCov">          6 :         FileInput(std::filesystem::path executablePath, std::chrono::milliseconds timeout, std::string path) : ExecutionInput(std::move(executablePath), std::move(timeout)), path(std::move(path)) {}</span></a>
<a name="462"><span class="lineNum">     462 </span>            : </a>
<a name="463"><span class="lineNum">     463 </span><span class="lineCov">          3 :         virtual std::vector&lt;std::string&gt; getArguments() const final</span></a>
<a name="464"><span class="lineNum">     464 </span>            :         {</a>
<a name="465"><span class="lineNum">     465 </span><span class="lineCov">          6 :             return { path };</span></a>
<a name="466"><span class="lineNum">     466 </span>            :         }</a>
<a name="467"><span class="lineNum">     467 </span><span class="lineCov">          3 :         virtual std::string_view getCin() const final</span></a>
<a name="468"><span class="lineNum">     468 </span>            :         {</a>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">          3 :             return &quot;&quot;;</span></a>
<a name="470"><span class="lineNum">     470 </span>            :         }</a>
<a name="471"><span class="lineNum">     471 </span>            : </a>
<a name="472"><span class="lineNum">     472 </span><span class="lineNoCov">          0 :         virtual void setInput(const std::string_view&amp; input) final</span></a>
<a name="473"><span class="lineNum">     473 </span>            :         {</a>
<a name="474"><span class="lineNum">     474 </span><span class="lineNoCov">          0 :             std::ofstream fuzzInput(path);</span></a>
<a name="475"><span class="lineNum">     475 </span><span class="lineNoCov">          0 :             fuzzInput &lt;&lt; input;</span></a>
<a name="476"><span class="lineNum">     476 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="477"><span class="lineNum">     477 </span>            : </a>
<a name="478"><span class="lineNum">     478 </span><span class="lineCov">          9 :         virtual ~FileInput() = default;</span></a>
<a name="479"><span class="lineNum">     479 </span>            :     private:</a>
<a name="480"><span class="lineNum">     480 </span>            :         const std::string path;</a>
<a name="481"><span class="lineNum">     481 </span>            :     };</a>
<a name="482"><span class="lineNum">     482 </span>            : </a>
<a name="483"><span class="lineNum">     483 </span>            :     /// &lt;summary&gt;</a>
<a name="484"><span class="lineNum">     484 </span>            :     /// Execution input in form of a standard input</a>
<a name="485"><span class="lineNum">     485 </span>            :     /// &lt;/summary&gt;</a>
<a name="486"><span class="lineNum">     486 </span>            :     struct CinInput final : public ExecutionInput</a>
<a name="487"><span class="lineNum">     487 </span>            :     {</a>
<a name="488"><span class="lineNum">     488 </span><span class="lineCov">          6 :         CinInput(std::filesystem::path executablePath, std::chrono::milliseconds timeout) : ExecutionInput(std::move(executablePath), std::move(timeout)) {}</span></a>
<a name="489"><span class="lineNum">     489 </span>            : </a>
<a name="490"><span class="lineNum">     490 </span><span class="lineCov">         15 :         virtual std::vector&lt;std::string&gt; getArguments() const final</span></a>
<a name="491"><span class="lineNum">     491 </span>            :         {</a>
<a name="492"><span class="lineNum">     492 </span><span class="lineCov">         15 :             return {};</span></a>
<a name="493"><span class="lineNum">     493 </span>            :         }</a>
<a name="494"><span class="lineNum">     494 </span><span class="lineCov">         15 :         virtual std::string_view getCin() const final</span></a>
<a name="495"><span class="lineNum">     495 </span>            :         {</a>
<a name="496"><span class="lineNum">     496 </span><span class="lineCov">         15 :             return cinInput;</span></a>
<a name="497"><span class="lineNum">     497 </span>            :         }</a>
<a name="498"><span class="lineNum">     498 </span>            : </a>
<a name="499"><span class="lineNum">     499 </span><span class="lineCov">         14 :         virtual void setInput(const std::string_view&amp; input) final</span></a>
<a name="500"><span class="lineNum">     500 </span>            :         {</a>
<a name="501"><span class="lineNum">     501 </span><span class="lineCov">         14 :             cinInput = input;</span></a>
<a name="502"><span class="lineNum">     502 </span><span class="lineCov">         14 :         }</span></a>
<a name="503"><span class="lineNum">     503 </span><span class="lineCov">          1 :         virtual void setInput(std::string_view&amp;&amp; input) final</span></a>
<a name="504"><span class="lineNum">     504 </span>            :         {</a>
<a name="505"><span class="lineNum">     505 </span><span class="lineCov">          1 :             cinInput = std::move(input);</span></a>
<a name="506"><span class="lineNum">     506 </span><span class="lineCov">          1 :         }</span></a>
<a name="507"><span class="lineNum">     507 </span>            : </a>
<a name="508"><span class="lineNum">     508 </span><span class="lineCov">         11 :         virtual ~CinInput() = default;</span></a>
<a name="509"><span class="lineNum">     509 </span>            : </a>
<a name="510"><span class="lineNum">     510 </span>            :     private:</a>
<a name="511"><span class="lineNum">     511 </span>            :         std::string_view cinInput;</a>
<a name="512"><span class="lineNum">     512 </span>            :     };</a>
<a name="513"><span class="lineNum">     513 </span>            : </a>
<a name="514"><span class="lineNum">     514 </span>            :     /// &lt;summary&gt;</a>
<a name="515"><span class="lineNum">     515 </span>            :     /// Execute program in the system with a timeout and return its results</a>
<a name="516"><span class="lineNum">     516 </span>            :     /// &lt;/summary&gt;</a>
<a name="517"><span class="lineNum">     517 </span>            :     /// &lt;param name=&quot;executionInput&quot;&gt;What to execute and how&lt;/param&gt;</a>
<a name="518"><span class="lineNum">     518 </span>            :     /// &lt;returns&gt;Result of the executions&lt;/returns&gt;</a>
<a name="519"><span class="lineNum">     519 </span><span class="lineCov">         18 :     ExecutionResult execute_with_timeout(const ExecutionInput&amp; executionInput) {</span></a>
<a name="520"><span class="lineNum">     520 </span>            :         using namespace boost::process;</a>
<a name="521"><span class="lineNum">     521 </span>            : </a>
<a name="522"><span class="lineNum">     522 </span>            : #ifdef CAPTURE_STDOUT</a>
<a name="523"><span class="lineNum">     523 </span><span class="lineCov">         18 :         ipstream stdout_stream;  // To capture standard output</span></a>
<a name="524"><span class="lineNum">     524 </span>            : #endif</a>
<a name="525"><span class="lineNum">     525 </span><span class="lineCov">         18 :         ipstream stderr_stream;  // To capture standard error</span></a>
<a name="526"><span class="lineNum">     526 </span><span class="lineCov">         18 :         opstream stdin_stream;   // To provide input</span></a>
<a name="527"><span class="lineNum">     527 </span>            : </a>
<a name="528"><span class="lineNum">     528 </span><span class="lineCov">         18 :         auto start = std::chrono::high_resolution_clock::now();</span></a>
<a name="529"><span class="lineNum">     529 </span>            :         child process(</a>
<a name="530"><span class="lineNum">     530 </span><span class="lineCov">         36 :             executionInput.executablePath.c_str(),</span></a>
<a name="531"><span class="lineNum">     531 </span><span class="lineCov">         18 :             executionInput.getArguments(),</span></a>
<a name="532"><span class="lineNum">     532 </span>            : #ifdef CAPTURE_STDOUT</a>
<a name="533"><span class="lineNum">     533 </span><span class="lineCov">         18 :             std_out &gt; stdout_stream,</span></a>
<a name="534"><span class="lineNum">     534 </span>            : #else</a>
<a name="535"><span class="lineNum">     535 </span>            :             std_out &gt; boost::process::null,</a>
<a name="536"><span class="lineNum">     536 </span>            : #endif</a>
<a name="537"><span class="lineNum">     537 </span><span class="lineCov">         18 :             std_err &gt; stderr_stream,</span></a>
<a name="538"><span class="lineNum">     538 </span><span class="lineCov">         18 :             std_in &lt; stdin_stream</span></a>
<a name="539"><span class="lineNum">     539 </span><span class="lineCov">         18 :         );</span></a>
<a name="540"><span class="lineNum">     540 </span>            : </a>
<a name="541"><span class="lineNum">     541 </span>            :         // Feed the process's standard input.</a>
<a name="542"><span class="lineNum">     542 </span><span class="lineCov">         18 :         stdin_stream &lt;&lt; executionInput.getCin();</span></a>
<a name="543"><span class="lineNum">     543 </span><span class="lineCov">         18 :         stdin_stream.flush();</span></a>
<a name="544"><span class="lineNum">     544 </span><span class="lineCov">         18 :         stdin_stream.close();</span></a>
<a name="545"><span class="lineNum">     545 </span><span class="lineCov">         18 :         stdin_stream.pipe().close();  // Close stdin to signal end of input</span></a>
<a name="546"><span class="lineNum">     546 </span>            : </a>
<a name="547"><span class="lineNum">     547 </span>            :         // Read all content from ipstream after the process finishes</a>
<a name="548"><span class="lineNum">     548 </span><span class="lineCov">         36 :         auto read_stream = [](ipstream&amp; stream) {</span></a>
<a name="549"><span class="lineNum">     549 </span><span class="lineCov">         36 :             std::ostringstream oss;</span></a>
<a name="550"><span class="lineNum">     550 </span><span class="lineCov">         36 :             oss &lt;&lt; stream.rdbuf(); // Efficiently reads the entire stream buffer</span></a>
<a name="551"><span class="lineNum">     551 </span><span class="lineCov">         72 :             return oss.str();</span></a>
<a name="552"><span class="lineNum">     552 </span><span class="lineCov">         36 :         };</span></a>
<a name="553"><span class="lineNum">     553 </span>            :         </a>
<a name="554"><span class="lineNum">     554 </span>            :         // Wait for process completion with a timeout.</a>
<a name="555"><span class="lineNum">     555 </span><span class="lineCov">         18 :         bool finished_in_time = process.wait_for(executionInput.timeout);</span></a>
<a name="556"><span class="lineNum">     556 </span><span class="lineCov">         18 :         if (!finished_in_time) {</span></a>
<a name="557"><span class="lineNum">     557 </span><span class="lineCov">          1 :             process.terminate();  // Kill the process if it times out</span></a>
<a name="558"><span class="lineNum">     558 </span><span class="lineCov">          1 :             auto duration = std::chrono::duration_cast&lt;std::chrono::duration&lt;double, std::milli&gt;&gt;(std::chrono::high_resolution_clock::now() - start);</span></a>
<a name="559"><span class="lineNum">     559 </span><span class="lineCov">          1 :             statisticsExecution.addNumber(duration.count());</span></a>
<a name="560"><span class="lineNum">     560 </span><span class="lineCov">          1 :             nb_hanged_runs.fetch_add(1, std::memory_order_relaxed);</span></a>
<a name="561"><span class="lineNum">     561 </span>            :             return {</a>
<a name="562"><span class="lineNum">     562 </span>            :                 -1,</a>
<a name="563"><span class="lineNum">     563 </span>            : #ifdef CAPTURE_STDOUT</a>
<a name="564"><span class="lineNum">     564 </span>            :                 read_stream(stdout_stream),</a>
<a name="565"><span class="lineNum">     565 </span>            : #endif</a>
<a name="566"><span class="lineNum">     566 </span>            :                 read_stream(stderr_stream),</a>
<a name="567"><span class="lineNum">     567 </span>            :                 true,</a>
<a name="568"><span class="lineNum">     568 </span>            :                 duration </a>
<a name="569"><span class="lineNum">     569 </span><span class="lineCov">          1 :            };  // Indicate a timeout occurred</span></a>
<a name="570"><span class="lineNum">     570 </span>            :         }</a>
<a name="571"><span class="lineNum">     571 </span>            : </a>
<a name="572"><span class="lineNum">     572 </span><span class="lineCov">         17 :         auto duration = std::chrono::duration_cast&lt;std::chrono::duration&lt;double, std::milli&gt;&gt;(std::chrono::high_resolution_clock::now() - start);</span></a>
<a name="573"><span class="lineNum">     573 </span><span class="lineCov">         17 :         statisticsExecution.addNumber(duration.count());</span></a>
<a name="574"><span class="lineNum">     574 </span><span class="lineCov">         17 :         if (process.exit_code() != 0)</span></a>
<a name="575"><span class="lineNum">     575 </span><span class="lineCov">         15 :             nb_failed_runs.fetch_add(1, std::memory_order_relaxed);</span></a>
<a name="576"><span class="lineNum">     576 </span>            : </a>
<a name="577"><span class="lineNum">     577 </span>            :         // Retrieve the outputs and return code</a>
<a name="578"><span class="lineNum">     578 </span>            :         return { </a>
<a name="579"><span class="lineNum">     579 </span><span class="lineCov">         17 :             std::move(process.exit_code()),</span></a>
<a name="580"><span class="lineNum">     580 </span>            : #ifdef CAPTURE_STDOUT</a>
<a name="581"><span class="lineNum">     581 </span>            :             read_stream(stdout_stream),</a>
<a name="582"><span class="lineNum">     582 </span>            : #endif</a>
<a name="583"><span class="lineNum">     583 </span>            :             read_stream(stderr_stream),</a>
<a name="584"><span class="lineNum">     584 </span>            :             false,</a>
<a name="585"><span class="lineNum">     585 </span>            :             duration</a>
<a name="586"><span class="lineNum">     586 </span><span class="lineCov">         17 :         };</span></a>
<a name="587"><span class="lineNum">     587 </span><span class="lineCov">         18 :     }</span></a>
<a name="588"><span class="lineNum">     588 </span>            : </a>
<a name="589"><span class="lineNum">     589 </span>            :     /// &lt;summary&gt;</a>
<a name="590"><span class="lineNum">     590 </span>            :     /// Base class for various errors that the oracle catches</a>
<a name="591"><span class="lineNum">     591 </span>            :     /// &lt;/summary&gt;</a>
<a name="592"><span class="lineNum">     592 </span>            :     struct DetectedError</a>
<a name="593"><span class="lineNum">     593 </span>            :     {</a>
<a name="594"><span class="lineNum">     594 </span>            :         /// &lt;summary&gt;</a>
<a name="595"><span class="lineNum">     595 </span>            :         /// Checks whether this error was present in the output</a>
<a name="596"><span class="lineNum">     596 </span>            :         /// &lt;/summary&gt;</a>
<a name="597"><span class="lineNum">     597 </span>            :         virtual bool isErrorEncountered(const ExecutionResult&amp; executionResult) const = 0;</a>
<a name="598"><span class="lineNum">     598 </span>            : </a>
<a name="599"><span class="lineNum">     599 </span>            :         /// &lt;summary&gt;</a>
<a name="600"><span class="lineNum">     600 </span>            :         /// Name of the oracle, as it should be in JSON export</a>
<a name="601"><span class="lineNum">     601 </span>            :         /// &lt;/summary&gt;</a>
<a name="602"><span class="lineNum">     602 </span>            :         virtual const char* errorName() const = 0;</a>
<a name="603"><span class="lineNum">     603 </span>            : </a>
<a name="604"><span class="lineNum">     604 </span>            :         /// &lt;summary&gt;</a>
<a name="605"><span class="lineNum">     605 </span>            :         /// Folder that the oracle should export to</a>
<a name="606"><span class="lineNum">     606 </span>            :         /// &lt;/summary&gt;</a>
<a name="607"><span class="lineNum">     607 </span>            :         virtual const char* folder() const = 0;</a>
<a name="608"><span class="lineNum">     608 </span>            : </a>
<a name="609"><span class="lineNum">     609 </span>            :         /// &lt;summary&gt;</a>
<a name="610"><span class="lineNum">     610 </span>            :         /// Export info about this bug to a stream</a>
<a name="611"><span class="lineNum">     611 </span>            :         /// &lt;/summary&gt;</a>
<a name="612"><span class="lineNum">     612 </span>            :         virtual std::ostream&amp; bugInfo(std::ostream&amp; os) const = 0;</a>
<a name="613"><span class="lineNum">     613 </span>            : </a>
<a name="614"><span class="lineNum">     614 </span>            :         /// &lt;summary&gt;</a>
<a name="615"><span class="lineNum">     615 </span>            :         /// Compares if two errors are the same for deduplication purposes</a>
<a name="616"><span class="lineNum">     616 </span>            :         /// &lt;/summary&gt;</a>
<a name="617"><span class="lineNum">     617 </span>            :         virtual bool operator == (const DetectedError&amp; Other) const = 0;</a>
<a name="618"><span class="lineNum">     618 </span>            : </a>
<a name="619"><span class="lineNum">     619 </span><span class="lineCov">         25 :         virtual ~DetectedError() = default;</span></a>
<a name="620"><span class="lineNum">     620 </span>            :     };</a>
<a name="621"><span class="lineNum">     621 </span>            : </a>
<a name="622"><span class="lineNum">     622 </span>            :     /// &lt;summary&gt;</a>
<a name="623"><span class="lineNum">     623 </span>            :     /// Oracle that catches a non-zero return code</a>
<a name="624"><span class="lineNum">     624 </span>            :     /// &lt;/summary&gt;</a>
<a name="625"><span class="lineNum">     625 </span>            :     struct ReturnCodeError : public DetectedError</a>
<a name="626"><span class="lineNum">     626 </span>            :     {</a>
<a name="627"><span class="lineNum">     627 </span><span class="lineCov">         18 :         ReturnCodeError(int returnCode) : returnCode(std::move(returnCode)) {}</span></a>
<a name="628"><span class="lineNum">     628 </span>            : </a>
<a name="629"><span class="lineNum">     629 </span><span class="lineCov">         12 :         bool operator==(const ReturnCodeError&amp; other) const</span></a>
<a name="630"><span class="lineNum">     630 </span>            :         {</a>
<a name="631"><span class="lineNum">     631 </span><span class="lineCov">         12 :             return returnCode == other.returnCode;</span></a>
<a name="632"><span class="lineNum">     632 </span>            :         }</a>
<a name="633"><span class="lineNum">     633 </span><span class="lineNoCov">          0 :         virtual bool operator == (const DetectedError&amp; Other) const override {</span></a>
<a name="634"><span class="lineNum">     634 </span><span class="lineNoCov">          0 :             if (typeid(Other) == typeid(*this))</span></a>
<a name="635"><span class="lineNum">     635 </span>            :             {</a>
<a name="636"><span class="lineNum">     636 </span><span class="lineNoCov">          0 :                 const ReturnCodeError&amp; other = static_cast&lt;const ReturnCodeError&amp;&gt;(Other);</span></a>
<a name="637"><span class="lineNum">     637 </span>            : </a>
<a name="638"><span class="lineNum">     638 </span><span class="lineNoCov">          0 :                 return *this == other;</span></a>
<a name="639"><span class="lineNum">     639 </span>            :             }</a>
<a name="640"><span class="lineNum">     640 </span>            :             else</a>
<a name="641"><span class="lineNum">     641 </span><span class="lineNoCov">          0 :                 return false;</span></a>
<a name="642"><span class="lineNum">     642 </span>            :         }</a>
<a name="643"><span class="lineNum">     643 </span>            : </a>
<a name="644"><span class="lineNum">     644 </span><span class="lineCov">          4 :         ReturnCodeError(ReturnCodeError&amp;&amp;) = default;</span></a>
<a name="645"><span class="lineNum">     645 </span>            :         ReturnCodeError(const ReturnCodeError&amp;) = default;</a>
<a name="646"><span class="lineNum">     646 </span>            : </a>
<a name="647"><span class="lineNum">     647 </span><span class="lineCov">         15 :         static std::optional&lt;ReturnCodeError&gt; tryDetectError(const ExecutionResult&amp; executionResult)</span></a>
<a name="648"><span class="lineNum">     648 </span>            :         {</a>
<a name="649"><span class="lineNum">     649 </span><span class="lineCov">         15 :             std::optional&lt;ReturnCodeError&gt; res;</span></a>
<a name="650"><span class="lineNum">     650 </span>            : </a>
<a name="651"><span class="lineNum">     651 </span><span class="lineCov">         15 :             if (executionResult.return_code != EXIT_SUCCESS)</span></a>
<a name="652"><span class="lineNum">     652 </span><span class="lineCov">         15 :                 res.emplace(executionResult.return_code);</span></a>
<a name="653"><span class="lineNum">     653 </span>            : </a>
<a name="654"><span class="lineNum">     654 </span><span class="lineCov">         15 :             return res;</span></a>
<a name="655"><span class="lineNum">     655 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="656"><span class="lineNum">     656 </span>            : </a>
<a name="657"><span class="lineNum">     657 </span><span class="lineCov">         12 :         virtual bool isErrorEncountered(const ExecutionResult&amp; executionResult) const override</span></a>
<a name="658"><span class="lineNum">     658 </span>            :         {</a>
<a name="659"><span class="lineNum">     659 </span><span class="lineCov">         12 :             auto tmp = tryDetectError(executionResult);</span></a>
<a name="660"><span class="lineNum">     660 </span><span class="lineCov">         12 :             if (tmp.has_value() &amp;&amp; ((*tmp) == (*this)))</span></a>
<a name="661"><span class="lineNum">     661 </span><span class="lineCov">         12 :                 return true;</span></a>
<a name="662"><span class="lineNum">     662 </span>            : </a>
<a name="663"><span class="lineNum">     663 </span><span class="lineNoCov">          0 :             return false;</span></a>
<a name="664"><span class="lineNum">     664 </span><span class="lineCov">         12 :         }</span></a>
<a name="665"><span class="lineNum">     665 </span>            : </a>
<a name="666"><span class="lineNum">     666 </span><span class="lineCov">          5 :         virtual const char* errorName() const override</span></a>
<a name="667"><span class="lineNum">     667 </span>            :         {</a>
<a name="668"><span class="lineNum">     668 </span><span class="lineCov">          5 :             return &quot;return_code&quot;;</span></a>
<a name="669"><span class="lineNum">     669 </span>            :         }</a>
<a name="670"><span class="lineNum">     670 </span>            : </a>
<a name="671"><span class="lineNum">     671 </span><span class="lineCov">          5 :         virtual const char* folder() const override</span></a>
<a name="672"><span class="lineNum">     672 </span>            :         {</a>
<a name="673"><span class="lineNum">     673 </span><span class="lineCov">          5 :             return &quot;crashes&quot;;</span></a>
<a name="674"><span class="lineNum">     674 </span>            :         }</a>
<a name="675"><span class="lineNum">     675 </span>            : </a>
<a name="676"><span class="lineNum">     676 </span><span class="lineCov">          5 :         virtual std::ostream&amp; bugInfo(std::ostream&amp; os) const override</span></a>
<a name="677"><span class="lineNum">     677 </span>            :         {</a>
<a name="678"><span class="lineNum">     678 </span><span class="lineCov">          5 :             os &lt;&lt; returnCode;</span></a>
<a name="679"><span class="lineNum">     679 </span><span class="lineCov">          5 :             return os;</span></a>
<a name="680"><span class="lineNum">     680 </span>            :         }</a>
<a name="681"><span class="lineNum">     681 </span>            : </a>
<a name="682"><span class="lineNum">     682 </span><span class="lineCov">         25 :         virtual ~ReturnCodeError() = default;</span></a>
<a name="683"><span class="lineNum">     683 </span>            : </a>
<a name="684"><span class="lineNum">     684 </span>            :         const int returnCode;</a>
<a name="685"><span class="lineNum">     685 </span>            :     };</a>
<a name="686"><span class="lineNum">     686 </span>            : </a>
<a name="687"><span class="lineNum">     687 </span>            :     /// &lt;summary&gt;</a>
<a name="688"><span class="lineNum">     688 </span>            :     /// Oracle that catches hangs of the program</a>
<a name="689"><span class="lineNum">     689 </span>            :     /// &lt;/summary&gt;</a>
<a name="690"><span class="lineNum">     690 </span>            :     struct TimeoutError final : public DetectedError</a>
<a name="691"><span class="lineNum">     691 </span>            :     {</a>
<a name="692"><span class="lineNum">     692 </span><span class="lineCov">          1 :         bool operator==(const TimeoutError&amp; other) const</span></a>
<a name="693"><span class="lineNum">     693 </span>            :         {</a>
<a name="694"><span class="lineNum">     694 </span><span class="lineCov">          1 :             return true; //All timeouts are treated as equal</span></a>
<a name="695"><span class="lineNum">     695 </span>            :             // return timeout == other.timeout;</a>
<a name="696"><span class="lineNum">     696 </span>            :         }</a>
<a name="697"><span class="lineNum">     697 </span>            : </a>
<a name="698"><span class="lineNum">     698 </span><span class="lineCov">          2 :         TimeoutError(std::chrono::duration&lt;double, std::milli&gt; timeout) : timeout(std::move(timeout)) {}</span></a>
<a name="699"><span class="lineNum">     699 </span><span class="lineCov">          1 :         TimeoutError(TimeoutError&amp;&amp;) = default;</span></a>
<a name="700"><span class="lineNum">     700 </span>            :         TimeoutError(const TimeoutError&amp;) = default;</a>
<a name="701"><span class="lineNum">     701 </span>            : </a>
<a name="702"><span class="lineNum">     702 </span><span class="lineNoCov">          0 :         virtual bool operator == (const DetectedError&amp; Other) const override {</span></a>
<a name="703"><span class="lineNum">     703 </span><span class="lineNoCov">          0 :             if (typeid(Other) == typeid(*this))</span></a>
<a name="704"><span class="lineNum">     704 </span>            :             {</a>
<a name="705"><span class="lineNum">     705 </span><span class="lineNoCov">          0 :                 const TimeoutError&amp; other = static_cast&lt;const TimeoutError&amp;&gt;(Other);</span></a>
<a name="706"><span class="lineNum">     706 </span>            : </a>
<a name="707"><span class="lineNum">     707 </span><span class="lineNoCov">          0 :                 return *this == other;</span></a>
<a name="708"><span class="lineNum">     708 </span>            :             }</a>
<a name="709"><span class="lineNum">     709 </span>            :             else</a>
<a name="710"><span class="lineNum">     710 </span><span class="lineNoCov">          0 :                 return false;</span></a>
<a name="711"><span class="lineNum">     711 </span>            :         }</a>
<a name="712"><span class="lineNum">     712 </span>            : </a>
<a name="713"><span class="lineNum">     713 </span><span class="lineCov">          6 :         static std::optional&lt;TimeoutError&gt; tryDetectError(const ExecutionResult&amp; executionResult)</span></a>
<a name="714"><span class="lineNum">     714 </span>            :         {</a>
<a name="715"><span class="lineNum">     715 </span><span class="lineCov">          6 :             std::optional&lt;TimeoutError&gt; res;</span></a>
<a name="716"><span class="lineNum">     716 </span>            : </a>
<a name="717"><span class="lineNum">     717 </span><span class="lineCov">          6 :             if (executionResult.timed_out)</span></a>
<a name="718"><span class="lineNum">     718 </span><span class="lineCov">          2 :                 res.emplace(executionResult.execution_time);</span></a>
<a name="719"><span class="lineNum">     719 </span>            : </a>
<a name="720"><span class="lineNum">     720 </span><span class="lineCov">          6 :             return res;</span></a>
<a name="721"><span class="lineNum">     721 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="722"><span class="lineNum">     722 </span>            : </a>
<a name="723"><span class="lineNum">     723 </span><span class="lineCov">          1 :         virtual bool isErrorEncountered(const ExecutionResult&amp; executionResult) const final</span></a>
<a name="724"><span class="lineNum">     724 </span>            :         {</a>
<a name="725"><span class="lineNum">     725 </span><span class="lineCov">          1 :             auto tmp = tryDetectError(executionResult);</span></a>
<a name="726"><span class="lineNum">     726 </span><span class="lineCov">          1 :             if (tmp.has_value() &amp;&amp; ((*tmp) == (*this)))</span></a>
<a name="727"><span class="lineNum">     727 </span><span class="lineCov">          1 :                 return true;</span></a>
<a name="728"><span class="lineNum">     728 </span>            : </a>
<a name="729"><span class="lineNum">     729 </span><span class="lineNoCov">          0 :             return false;</span></a>
<a name="730"><span class="lineNum">     730 </span><span class="lineCov">          1 :         }</span></a>
<a name="731"><span class="lineNum">     731 </span>            : </a>
<a name="732"><span class="lineNum">     732 </span><span class="lineCov">          1 :         virtual const char* errorName() const final</span></a>
<a name="733"><span class="lineNum">     733 </span>            :         {</a>
<a name="734"><span class="lineNum">     734 </span><span class="lineCov">          1 :             return &quot;timeout&quot;;</span></a>
<a name="735"><span class="lineNum">     735 </span>            :         }</a>
<a name="736"><span class="lineNum">     736 </span>            : </a>
<a name="737"><span class="lineNum">     737 </span><span class="lineCov">          1 :         virtual const char* folder() const final</span></a>
<a name="738"><span class="lineNum">     738 </span>            :         {</a>
<a name="739"><span class="lineNum">     739 </span><span class="lineCov">          1 :             return &quot;hangs&quot;;</span></a>
<a name="740"><span class="lineNum">     740 </span>            :         }</a>
<a name="741"><span class="lineNum">     741 </span>            : </a>
<a name="742"><span class="lineNum">     742 </span><span class="lineCov">          1 :         virtual std::ostream&amp; bugInfo(std::ostream&amp; os) const override</span></a>
<a name="743"><span class="lineNum">     743 </span>            :         {</a>
<a name="744"><span class="lineNum">     744 </span><span class="lineCov">          1 :             os &lt;&lt; timeout.count();</span></a>
<a name="745"><span class="lineNum">     745 </span><span class="lineCov">          1 :             return os;</span></a>
<a name="746"><span class="lineNum">     746 </span>            :         }</a>
<a name="747"><span class="lineNum">     747 </span>            : </a>
<a name="748"><span class="lineNum">     748 </span><span class="lineCov">          4 :         virtual ~TimeoutError() = default;</span></a>
<a name="749"><span class="lineNum">     749 </span>            : </a>
<a name="750"><span class="lineNum">     750 </span>            :         std::chrono::duration&lt;double, std::milli&gt; timeout;</a>
<a name="751"><span class="lineNum">     751 </span>            :     };</a>
<a name="752"><span class="lineNum">     752 </span>            : </a>
<a name="753"><span class="lineNum">     753 </span>            :     virtual size_t asanOffset() const = 0;</a>
<a name="754"><span class="lineNum">     754 </span>            : </a>
<a name="755"><span class="lineNum">     755 </span>            :     /// &lt;summary&gt;</a>
<a name="756"><span class="lineNum">     756 </span>            :     /// Oracle that catches address sanitizer errors</a>
<a name="757"><span class="lineNum">     757 </span>            :     /// &lt;/summary&gt;</a>
<a name="758"><span class="lineNum">     758 </span>            :     struct AddressSanitizerError : public ReturnCodeError</a>
<a name="759"><span class="lineNum">     759 </span>            :     {</a>
<a name="760"><span class="lineNum">     760 </span><span class="lineCov">          3 :         AddressSanitizerError(std::string asanType, std::string file, std::string line) : asanType(std::move(asanType)), file(std::move(file)), line(std::move(line)), ReturnCodeError(1) {}</span></a>
<a name="761"><span class="lineNum">     761 </span>            : </a>
<a name="762"><span class="lineNum">     762 </span><span class="lineCov">          1 :         AddressSanitizerError(AddressSanitizerError&amp;&amp;) = default;</span></a>
<a name="763"><span class="lineNum">     763 </span>            :         AddressSanitizerError(const AddressSanitizerError&amp;) = default;</a>
<a name="764"><span class="lineNum">     764 </span>            : </a>
<a name="765"><span class="lineNum">     765 </span><span class="lineCov">          1 :         bool operator==(const AddressSanitizerError&amp; other) const</span></a>
<a name="766"><span class="lineNum">     766 </span>            :         {</a>
<a name="767"><span class="lineNum">     767 </span><span class="lineCov">          1 :             return other.asanType == asanType &amp;&amp; other.file == file &amp;&amp; other.line == line;</span></a>
<a name="768"><span class="lineNum">     768 </span>            :         }</a>
<a name="769"><span class="lineNum">     769 </span>            : </a>
<a name="770"><span class="lineNum">     770 </span><span class="lineNoCov">          0 :         virtual bool operator == (const DetectedError&amp; Other) const override {</span></a>
<a name="771"><span class="lineNum">     771 </span><span class="lineNoCov">          0 :             if (typeid(Other) == typeid(*this))</span></a>
<a name="772"><span class="lineNum">     772 </span>            :             {</a>
<a name="773"><span class="lineNum">     773 </span><span class="lineNoCov">          0 :                 const AddressSanitizerError&amp; other = static_cast&lt;const AddressSanitizerError&amp;&gt;(Other);</span></a>
<a name="774"><span class="lineNum">     774 </span>            : </a>
<a name="775"><span class="lineNum">     775 </span><span class="lineNoCov">          0 :                 return *this == other;</span></a>
<a name="776"><span class="lineNum">     776 </span>            :             }</a>
<a name="777"><span class="lineNum">     777 </span>            :             else</a>
<a name="778"><span class="lineNum">     778 </span><span class="lineNoCov">          0 :                 return false;</span></a>
<a name="779"><span class="lineNum">     779 </span>            :         }</a>
<a name="780"><span class="lineNum">     780 </span>            : </a>
<a name="781"><span class="lineNum">     781 </span><span class="lineCov">          4 :         virtual const char* errorName() const final</span></a>
<a name="782"><span class="lineNum">     782 </span>            :         {</a>
<a name="783"><span class="lineNum">     783 </span><span class="lineCov">          4 :             return &quot;asan&quot;;</span></a>
<a name="784"><span class="lineNum">     784 </span>            :         }</a>
<a name="785"><span class="lineNum">     785 </span>            : </a>
<a name="786"><span class="lineNum">     786 </span><span class="lineCov">          5 :         static std::optional&lt;AddressSanitizerError&gt; tryDetectError(const ExecutionResult&amp; executionResult)</span></a>
<a name="787"><span class="lineNum">     787 </span>            :         {</a>
<a name="788"><span class="lineNum">     788 </span><span class="lineCov">          5 :             std::optional&lt;AddressSanitizerError&gt; res;</span></a>
<a name="789"><span class="lineNum">     789 </span>            : </a>
<a name="790"><span class="lineNum">     790 </span><span class="lineCov">          5 :             if (executionResult.return_code == 1)</span></a>
<a name="791"><span class="lineNum">     791 </span>            :             {</a>
<a name="792"><span class="lineNum">     792 </span><span class="lineCov">          4 :                 std::smatch match;</span></a>
<a name="793"><span class="lineNum">     793 </span><span class="lineCov">          4 :                 if (std::regex_search(executionResult.stderr_output, match, errorTypeRegex))</span></a>
<a name="794"><span class="lineNum">     794 </span>            :                 {</a>
<a name="795"><span class="lineNum">     795 </span>            :                     //std::cerr &lt;&lt; &quot;Caught ASAN &quot; &lt;&lt; match[1] &lt;&lt; &quot; in &quot; &lt;&lt; std::endl &lt;&lt; executionResult.stderr_output &lt;&lt; std::endl;</a>
<a name="796"><span class="lineNum">     796 </span>            : </a>
<a name="797"><span class="lineNum">     797 </span><span class="lineCov">          2 :                     std::smatch match2;</span></a>
<a name="798"><span class="lineNum">     798 </span>            : </a>
<a name="799"><span class="lineNum">     799 </span><span class="lineCov">          2 :                     if (std::regex_search(executionResult.stderr_output, match2, locationRegex)) {</span></a>
<a name="800"><span class="lineNum">     800 </span><span class="lineCov">          2 :                         std::string asan;</span></a>
<a name="801"><span class="lineNum">     801 </span><span class="lineCov">          2 :                         if (match[1] == &quot;heap-buffer-overflow&quot;)</span></a>
<a name="802"><span class="lineNum">     802 </span><span class="lineCov">          2 :                             asan = &quot;heap&quot;;</span></a>
<a name="803"><span class="lineNum">     803 </span><span class="lineNoCov">          0 :                         else if (match[1] == &quot;stack-buffer-overflow&quot;)</span></a>
<a name="804"><span class="lineNum">     804 </span><span class="lineNoCov">          0 :                             asan = &quot;stack&quot;;</span></a>
<a name="805"><span class="lineNum">     805 </span><span class="lineNoCov">          0 :                         else if (match[1] == &quot;global-buffer-overflow&quot;)</span></a>
<a name="806"><span class="lineNum">     806 </span><span class="lineNoCov">          0 :                             asan = &quot;global&quot;;</span></a>
<a name="807"><span class="lineNum">     807 </span>            :                         else</a>
<a name="808"><span class="lineNum">     808 </span><span class="lineNoCov">          0 :                             asan = match[1];</span></a>
<a name="809"><span class="lineNum">     809 </span>            : </a>
<a name="810"><span class="lineNum">     810 </span><span class="lineCov">          2 :                         res.emplace(std::move(asan), match2[1], std::to_string(std::stoi(match2[2]) - currentAsanOffset));</span></a>
<a name="811"><span class="lineNum">     811 </span><span class="lineCov">          2 :                     }</span></a>
<a name="812"><span class="lineNum">     812 </span><span class="lineCov">          2 :                 }</span></a>
<a name="813"><span class="lineNum">     813 </span>            : </a>
<a name="814"><span class="lineNum">     814 </span><span class="lineCov">          4 :             }</span></a>
<a name="815"><span class="lineNum">     815 </span>            : </a>
<a name="816"><span class="lineNum">     816 </span><span class="lineCov">          5 :             return res;</span></a>
<a name="817"><span class="lineNum">     817 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="818"><span class="lineNum">     818 </span>            : </a>
<a name="819"><span class="lineNum">     819 </span><span class="lineCov">          1 :         virtual bool isErrorEncountered(const ExecutionResult&amp; executionResult) const override</span></a>
<a name="820"><span class="lineNum">     820 </span>            :         {</a>
<a name="821"><span class="lineNum">     821 </span><span class="lineCov">          1 :             auto tmp = tryDetectError(executionResult);</span></a>
<a name="822"><span class="lineNum">     822 </span><span class="lineCov">          1 :             if (tmp.has_value() &amp;&amp; ((*tmp) == (*this)))</span></a>
<a name="823"><span class="lineNum">     823 </span><span class="lineCov">          1 :                 return true;</span></a>
<a name="824"><span class="lineNum">     824 </span>            : </a>
<a name="825"><span class="lineNum">     825 </span><span class="lineNoCov">          0 :             return false;</span></a>
<a name="826"><span class="lineNum">     826 </span><span class="lineCov">          1 :         }</span></a>
<a name="827"><span class="lineNum">     827 </span>            : </a>
<a name="828"><span class="lineNum">     828 </span><span class="lineCov">          4 :         virtual std::ostream&amp; bugInfo(std::ostream&amp; os) const override</span></a>
<a name="829"><span class="lineNum">     829 </span>            :         {</a>
<a name="830"><span class="lineNum">     830 </span>            :             os &lt;&lt; &quot;{&quot;</a>
<a name="831"><span class="lineNum">     831 </span><span class="lineCov">          4 :                 &quot;\&quot;file\&quot;:\&quot;&quot; &lt;&lt; file &lt;&lt; &quot;\&quot;,&quot;</span></a>
<a name="832"><span class="lineNum">     832 </span><span class="lineCov">          4 :                 &quot;\&quot;line\&quot;:&quot; &lt;&lt; line &lt;&lt; &quot;,&quot;</span></a>
<a name="833"><span class="lineNum">     833 </span><span class="lineCov">          4 :                 &quot;\&quot;kind\&quot;:\&quot;&quot; &lt;&lt; asanType &lt;&lt; &quot;\&quot;&quot;</span></a>
<a name="834"><span class="lineNum">     834 </span><span class="lineCov">          4 :                 &quot;}&quot;</span></a>
<a name="835"><span class="lineNum">     835 </span>            :                 ;</a>
<a name="836"><span class="lineNum">     836 </span><span class="lineCov">          4 :             return os;</span></a>
<a name="837"><span class="lineNum">     837 </span>            :         }</a>
<a name="838"><span class="lineNum">     838 </span>            : </a>
<a name="839"><span class="lineNum">     839 </span>            :         const std::string asanType;</a>
<a name="840"><span class="lineNum">     840 </span>            :         const std::string file;</a>
<a name="841"><span class="lineNum">     841 </span>            :         const std::string line;</a>
<a name="842"><span class="lineNum">     842 </span>            : </a>
<a name="843"><span class="lineNum">     843 </span><span class="lineCov">          5 :         virtual ~AddressSanitizerError() = default;</span></a>
<a name="844"><span class="lineNum">     844 </span>            :     };</a>
<a name="845"><span class="lineNum">     845 </span>            : </a>
<a name="846"><span class="lineNum">     846 </span>            :     /// &lt;summary&gt;</a>
<a name="847"><span class="lineNum">     847 </span>            :     /// Catch error from runner output</a>
<a name="848"><span class="lineNum">     848 </span>            :     /// &lt;/summary&gt;</a>
<a name="849"><span class="lineNum">     849 </span>            :     /// &lt;param name=&quot;result&quot;&gt;Output from the runner&lt;/param&gt;</a>
<a name="850"><span class="lineNum">     850 </span>            :     /// &lt;returns&gt;Error present in this output. Nullptr if no error present.&lt;/returns&gt;</a>
<a name="851"><span class="lineNum">     851 </span><span class="lineCov">          5 :     static std::unique_ptr&lt;DetectedError&gt; detectError(const ExecutionResult&amp; result)</span></a>
<a name="852"><span class="lineNum">     852 </span>            :     {</a>
<a name="853"><span class="lineNum">     853 </span>            :         {</a>
<a name="854"><span class="lineNum">     854 </span><span class="lineCov">          5 :             auto tmp = TimeoutError::tryDetectError(result);</span></a>
<a name="855"><span class="lineNum">     855 </span><span class="lineCov">          5 :             if (tmp.has_value())</span></a>
<a name="856"><span class="lineNum">     856 </span><span class="lineCov">          1 :                 return std::make_unique&lt;TimeoutError&gt;(std::move(*tmp));</span></a>
<a name="857"><span class="lineNum">     857 </span><span class="lineCov">          5 :         }</span></a>
<a name="858"><span class="lineNum">     858 </span>            :         {</a>
<a name="859"><span class="lineNum">     859 </span><span class="lineCov">          4 :             auto tmp = AddressSanitizerError::tryDetectError(result);</span></a>
<a name="860"><span class="lineNum">     860 </span><span class="lineCov">          4 :             if (tmp.has_value())</span></a>
<a name="861"><span class="lineNum">     861 </span><span class="lineCov">          1 :                 return std::make_unique&lt;AddressSanitizerError&gt;(std::move(*tmp));</span></a>
<a name="862"><span class="lineNum">     862 </span><span class="lineCov">          4 :         }</span></a>
<a name="863"><span class="lineNum">     863 </span>            :         {</a>
<a name="864"><span class="lineNum">     864 </span><span class="lineCov">          3 :             auto tmp = ReturnCodeError::tryDetectError(result);</span></a>
<a name="865"><span class="lineNum">     865 </span><span class="lineCov">          3 :             if (tmp.has_value())</span></a>
<a name="866"><span class="lineNum">     866 </span><span class="lineCov">          3 :                 return std::make_unique&lt;ReturnCodeError&gt;(std::move(*tmp));</span></a>
<a name="867"><span class="lineNum">     867 </span><span class="lineCov">          3 :         }</span></a>
<a name="868"><span class="lineNum">     868 </span>            : </a>
<a name="869"><span class="lineNum">     869 </span><span class="lineNoCov">          0 :         return std::unique_ptr&lt;DetectedError&gt;();</span></a>
<a name="870"><span class="lineNum">     870 </span>            :     }</a>
<a name="871"><span class="lineNum">     871 </span>            : </a>
<a name="872"><span class="lineNum">     872 </span>            :     /// &lt;summary&gt;</a>
<a name="873"><span class="lineNum">     873 </span>            :     /// Minimize input in a way that the same error still persists, but the input is shortest as possible</a>
<a name="874"><span class="lineNum">     874 </span>            :     /// &lt;/summary&gt;</a>
<a name="875"><span class="lineNum">     875 </span>            :     /// &lt;param name=&quot;input&quot;&gt;Unminimized input string that throws error&lt;/param&gt;</a>
<a name="876"><span class="lineNum">     876 </span>            :     /// &lt;param name=&quot;prevResult&quot;&gt;Error that should be hit&lt;/param&gt;</a>
<a name="877"><span class="lineNum">     877 </span>            :     /// &lt;param name=&quot;executionInput&quot;&gt;Where to test all the inputs&lt;/param&gt;</a>
<a name="878"><span class="lineNum">     878 </span>            :     /// &lt;param name=&quot;totalRuns&quot;&gt;How many times it runs (statistic purposes)&lt;/param&gt;</a>
<a name="879"><span class="lineNum">     879 </span>            :     /// &lt;returns&gt;Minimized string&lt;/returns&gt;</a>
<a name="880"><span class="lineNum">     880 </span><span class="lineCov">         13 :     std::string minimizeInput(const std::string_view&amp; input, const DetectedError&amp; prevResult, ExecutionInput&amp; executionInput, size_t&amp; totalRuns)</span></a>
<a name="881"><span class="lineNum">     881 </span>            :     {</a>
<a name="882"><span class="lineNum">     882 </span><span class="lineCov">         13 :         constexpr int divisionsStepStart = 2;</span></a>
<a name="883"><span class="lineNum">     883 </span><span class="lineCov">         13 :         int divisionStep = divisionsStepStart - 1;</span></a>
<a name="884"><span class="lineNum">     884 </span><span class="lineCov">         13 :         int prevStep = -1;</span></a>
<a name="885"><span class="lineNum">     885 </span>            : </a>
<a name="886"><span class="lineNum">     886 </span>            :         while (true)</a>
<a name="887"><span class="lineNum">     887 </span>            :         {</a>
<a name="888"><span class="lineNum">     888 </span>            :             int step;</a>
<a name="889"><span class="lineNum">     889 </span>            : </a>
<a name="890"><span class="lineNum">     890 </span>            :             do</a>
<a name="891"><span class="lineNum">     891 </span>            :             {</a>
<a name="892"><span class="lineNum">     892 </span><span class="lineCov">         13 :                 step = input.length() / ++divisionStep;</span></a>
<a name="893"><span class="lineNum">     893 </span><span class="lineCov">         13 :             } while (step == prevStep);</span></a>
<a name="894"><span class="lineNum">     894 </span><span class="lineCov">         13 :             prevStep = step;</span></a>
<a name="895"><span class="lineNum">     895 </span>            : </a>
<a name="896"><span class="lineNum">     896 </span><span class="lineCov">         13 :             if (step &lt; 1)</span></a>
<a name="897"><span class="lineNum">     897 </span><span class="lineCov">          2 :                 return std::string(input);</span></a>
<a name="898"><span class="lineNum">     898 </span>            : </a>
<a name="899"><span class="lineNum">     899 </span>            :             //Step 1</a>
<a name="900"><span class="lineNum">     900 </span><span class="lineCov">         11 :             for (size_t i = 0; i &lt; input.length(); i += step)</span></a>
<a name="901"><span class="lineNum">     901 </span>            :             {</a>
<a name="902"><span class="lineNum">     902 </span><span class="lineCov">         11 :                 auto cropped = input.substr(i, step);</span></a>
<a name="903"><span class="lineNum">     903 </span><span class="lineCov">         11 :                 executionInput.setInput(cropped);</span></a>
<a name="904"><span class="lineNum">     904 </span>            : </a>
<a name="905"><span class="lineNum">     905 </span><span class="lineCov">         11 :                 totalRuns += 1;</span></a>
<a name="906"><span class="lineNum">     906 </span><span class="lineCov">         11 :                 auto result = execute_with_timeout(executionInput);</span></a>
<a name="907"><span class="lineNum">     907 </span><span class="lineCov">         11 :                 if (prevResult.isErrorEncountered(result))</span></a>
<a name="908"><span class="lineNum">     908 </span>            :                 {</a>
<a name="909"><span class="lineNum">     909 </span><span class="lineCov">         11 :                     return minimizeInput(cropped, prevResult, executionInput, totalRuns);</span></a>
<a name="910"><span class="lineNum">     910 </span>            :                 }</a>
<a name="911"><span class="lineNum">     911 </span>            :                 else</a>
<a name="912"><span class="lineNum">     912 </span>            :                 {</a>
<a name="913"><span class="lineNum">     913 </span><span class="lineNoCov">          0 :                     dealWithResult(input, std::move(result), executionInput, true);// Minimization discovered a different bug, remember for later</span></a>
<a name="914"><span class="lineNum">     914 </span>            :                 }</a>
<a name="915"><span class="lineNum">     915 </span><span class="lineCov">         11 :             }</span></a>
<a name="916"><span class="lineNum">     916 </span>            : </a>
<a name="917"><span class="lineNum">     917 </span>            :             //Step 2</a>
<a name="918"><span class="lineNum">     918 </span><span class="lineNoCov">          0 :             for (size_t i = 0; i &lt; input.length(); i += step)</span></a>
<a name="919"><span class="lineNum">     919 </span>            :             {</a>
<a name="920"><span class="lineNum">     920 </span><span class="lineNoCov">          0 :                 std::string complement;</span></a>
<a name="921"><span class="lineNum">     921 </span><span class="lineNoCov">          0 :                 complement.reserve(input.size() - step);</span></a>
<a name="922"><span class="lineNum">     922 </span><span class="lineNoCov">          0 :                 complement += input.substr(0, i);</span></a>
<a name="923"><span class="lineNum">     923 </span><span class="lineNoCov">          0 :                 if (i + step &lt; input.length())</span></a>
<a name="924"><span class="lineNum">     924 </span><span class="lineNoCov">          0 :                     complement += input.substr(i + step);</span></a>
<a name="925"><span class="lineNum">     925 </span>            : </a>
<a name="926"><span class="lineNum">     926 </span><span class="lineNoCov">          0 :                 executionInput.setInput(complement);</span></a>
<a name="927"><span class="lineNum">     927 </span>            : </a>
<a name="928"><span class="lineNum">     928 </span><span class="lineNoCov">          0 :                 totalRuns += 1;</span></a>
<a name="929"><span class="lineNum">     929 </span><span class="lineNoCov">          0 :                 auto result = execute_with_timeout(executionInput);</span></a>
<a name="930"><span class="lineNum">     930 </span><span class="lineNoCov">          0 :                 if (prevResult.isErrorEncountered(result))</span></a>
<a name="931"><span class="lineNum">     931 </span>            :                 {</a>
<a name="932"><span class="lineNum">     932 </span><span class="lineNoCov">          0 :                     return minimizeInput(complement, prevResult, executionInput, totalRuns);</span></a>
<a name="933"><span class="lineNum">     933 </span>            :                 }</a>
<a name="934"><span class="lineNum">     934 </span>            :                 else</a>
<a name="935"><span class="lineNum">     935 </span>            :                 {</a>
<a name="936"><span class="lineNum">     936 </span><span class="lineNoCov">          0 :                     dealWithResult(input, std::move(result), executionInput, true);// Minimization discovered a different bug, remember for later</span></a>
<a name="937"><span class="lineNum">     937 </span>            :                 }</a>
<a name="938"><span class="lineNum">     938 </span><span class="lineNoCov">          0 :             }</span></a>
<a name="939"><span class="lineNum">     939 </span>            : </a>
<a name="940"><span class="lineNum">     940 </span>            :             //Step 3</a>
<a name="941"><span class="lineNum">     941 </span>            : </a>
<a name="942"><span class="lineNum">     942 </span>            :             //If it arrives here, it means we can't minimize at this granularity</a>
<a name="943"><span class="lineNum">     943 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="944"><span class="lineNum">     944 </span>            :     }</a>
<a name="945"><span class="lineNum">     945 </span>            : </a>
<a name="946"><span class="lineNum">     946 </span>            :     /// &lt;summary&gt;</a>
<a name="947"><span class="lineNum">     947 </span>            :     /// JSON crash report</a>
<a name="948"><span class="lineNum">     948 </span>            :     /// &lt;/summary&gt;</a>
<a name="949"><span class="lineNum">     949 </span>            :     struct CrashReport</a>
<a name="950"><span class="lineNum">     950 </span>            :     {</a>
<a name="951"><span class="lineNum">     951 </span>            :         std::string input;</a>
<a name="952"><span class="lineNum">     952 </span>            :         DetectedError* detectedError;</a>
<a name="953"><span class="lineNum">     953 </span>            :         std::chrono::duration&lt;double, std::milli&gt; execution_time;</a>
<a name="954"><span class="lineNum">     954 </span>            :         size_t unminimized_size;</a>
<a name="955"><span class="lineNum">     955 </span>            :         size_t nb_steps;</a>
<a name="956"><span class="lineNum">     956 </span>            :         std::chrono::duration&lt;double, std::milli&gt; minimization_time;</a>
<a name="957"><span class="lineNum">     957 </span>            :     };</a>
<a name="958"><span class="lineNum">     958 </span>            : </a>
<a name="959"><span class="lineNum">     959 </span>            :     /// &lt;summary&gt;</a>
<a name="960"><span class="lineNum">     960 </span>            :     /// Export information same for all fuzzers about a crash into a stream</a>
<a name="961"><span class="lineNum">     961 </span>            :     /// &lt;/summary&gt;</a>
<a name="962"><span class="lineNum">     962 </span><span class="lineCov">          7 :     static void exportReportCommon(const CrashReport&amp; report, std::ostream&amp; output)</span></a>
<a name="963"><span class="lineNum">     963 </span>            :     {</a>
<a name="964"><span class="lineNum">     964 </span>            :         output &lt;&lt;</a>
<a name="965"><span class="lineNum">     965 </span>            : </a>
<a name="966"><span class="lineNum">     966 </span><span class="lineCov">          7 :             &quot;\&quot;input\&quot;:&quot;            &quot;\&quot;&quot;  ; escape(output, report.input) &lt;&lt; &quot;\&quot;,&quot;</span></a>
<a name="967"><span class="lineNum">     967 </span><span class="lineCov">          7 :             &quot;\&quot;oracle\&quot;:&quot;           &quot;\&quot;&quot; &lt;&lt; report.detectedError-&gt;errorName() &lt;&lt; &quot;\&quot;,&quot;</span></a>
<a name="968"><span class="lineNum">     968 </span><span class="lineCov">          7 :             &quot;\&quot;bug_info\&quot;:&quot;;                report.detectedError-&gt;bugInfo(output) &lt;&lt; &quot;,&quot;</span></a>
<a name="969"><span class="lineNum">     969 </span><span class="lineCov">          7 :             &quot;\&quot;execution_time\&quot;:&quot; &lt;&lt; report.execution_time.count() &lt;&lt;</span></a>
<a name="970"><span class="lineNum">     970 </span>            :             &quot;,\&quot;minimization\&quot;:{&quot;</a>
<a name="971"><span class="lineNum">     971 </span><span class="lineCov">          7 :             &quot;\&quot;unminimized_size\&quot;:&quot; &lt;&lt; report.unminimized_size &lt;&lt; &quot;,&quot;</span></a>
<a name="972"><span class="lineNum">     972 </span><span class="lineCov">          7 :             &quot;\&quot;nb_steps\&quot;:&quot; &lt;&lt; report.nb_steps &lt;&lt; &quot;,&quot;</span></a>
<a name="973"><span class="lineNum">     973 </span><span class="lineCov">          7 :             &quot;\&quot;execution_time\&quot;:&quot; &lt;&lt; report.minimization_time.count() &lt;&lt; &quot;&quot;</span></a>
<a name="974"><span class="lineNum">     974 </span><span class="lineCov">          7 :             &quot;}&quot;</span></a>
<a name="975"><span class="lineNum">     975 </span>            :             ;</a>
<a name="976"><span class="lineNum">     976 </span><span class="lineCov">          7 :     }</span></a>
<a name="977"><span class="lineNum">     977 </span>            : </a>
<a name="978"><span class="lineNum">     978 </span>            :     /// &lt;summary&gt;</a>
<a name="979"><span class="lineNum">     979 </span>            :     /// Export information about the report into a stream</a>
<a name="980"><span class="lineNum">     980 </span>            :     /// &lt;/summary&gt;</a>
<a name="981"><span class="lineNum">     981 </span>            :     virtual void exportReport(const CrashReport&amp; report, std::ostream&amp; output) const = 0;</a>
<a name="982"><span class="lineNum">     982 </span>            : </a>
<a name="983"><span class="lineNum">     983 </span>            :     /// &lt;summary&gt;</a>
<a name="984"><span class="lineNum">     984 </span>            :     /// Save the report about an error into a file</a>
<a name="985"><span class="lineNum">     985 </span>            :     /// &lt;/summary&gt;</a>
<a name="986"><span class="lineNum">     986 </span>            :     /// &lt;param name=&quot;report&quot;&gt;Report to save&lt;/param&gt;</a>
<a name="987"><span class="lineNum">     987 </span>            :     /// &lt;param name=&quot;name&quot;&gt;Name of the file to save to&lt;/param&gt;</a>
<a name="988"><span class="lineNum">     988 </span>            :     /// &lt;param name=&quot;resultFolder&quot;&gt;Where to save it&lt;/param&gt;</a>
<a name="989"><span class="lineNum">     989 </span><span class="lineCov">          3 :     void saveReport(const CrashReport&amp; report, const std::string&amp; name, const std::filesystem::path&amp; resultFolder)</span></a>
<a name="990"><span class="lineNum">     990 </span>            :     {</a>
<a name="991"><span class="lineNum">     991 </span><span class="lineCov">          3 :         std::filesystem::path resultFile;</span></a>
<a name="992"><span class="lineNum">     992 </span>            : </a>
<a name="993"><span class="lineNum">     993 </span><span class="lineCov">          3 :         resultFile = resultFolder / report.detectedError-&gt;folder();</span></a>
<a name="994"><span class="lineNum">     994 </span>            : </a>
<a name="995"><span class="lineNum">     995 </span><span class="lineCov">          3 :         std::filesystem::create_directories(resultFile);</span></a>
<a name="996"><span class="lineNum">     996 </span>            : </a>
<a name="997"><span class="lineNum">     997 </span><span class="lineCov">          3 :         resultFile /= name;</span></a>
<a name="998"><span class="lineNum">     998 </span>            : </a>
<a name="999"><span class="lineNum">     999 </span><span class="lineCov">          3 :         std::ofstream output(resultFile);</span></a>
<a name="1000"><span class="lineNum">    1000 </span>            : </a>
<a name="1001"><span class="lineNum">    1001 </span><span class="lineCov">          3 :         exportReport(report, output);</span></a>
<a name="1002"><span class="lineNum">    1002 </span>            : </a>
<a name="1003"><span class="lineNum">    1003 </span><span class="lineCov">          3 :         std::cout &lt;&lt; &quot;New error report: \n&quot;;</span></a>
<a name="1004"><span class="lineNum">    1004 </span><span class="lineCov">          3 :         exportReport(report, std::cout);</span></a>
<a name="1005"><span class="lineNum">    1005 </span><span class="lineCov">          3 :         std::cout &lt;&lt; std::endl;</span></a>
<a name="1006"><span class="lineNum">    1006 </span>            : </a>
<a name="1007"><span class="lineNum">    1007 </span><span class="lineCov">          3 :         if (!output)</span></a>
<a name="1008"><span class="lineNum">    1008 </span><span class="lineNoCov">          0 :             std::cerr &lt;&lt; &quot;Error saving report!&quot; &lt;&lt; std::endl;</span></a>
<a name="1009"><span class="lineNum">    1009 </span><span class="lineCov">          3 :     }</span></a>
<a name="1010"><span class="lineNum">    1010 </span>            : </a>
<a name="1011"><span class="lineNum">    1011 </span>            :     const std::filesystem::path FUZZED_PROG;</a>
<a name="1012"><span class="lineNum">    1012 </span>            :     const std::filesystem::path RESULT_FUZZ;</a>
<a name="1013"><span class="lineNum">    1013 </span>            :     const bool MINIMIZE;</a>
<a name="1014"><span class="lineNum">    1014 </span>            :     const std::string_view fuzzInputType;</a>
<a name="1015"><span class="lineNum">    1015 </span>            :     const std::chrono::seconds TIMEOUT;</a>
<a name="1016"><span class="lineNum">    1016 </span>            :     const size_t NB_KNOWN_BUGS;</a>
<a name="1017"><span class="lineNum">    1017 </span>            : </a>
<a name="1018"><span class="lineNum">    1018 </span>            : </a>
<a name="1019"><span class="lineNum">    1019 </span>            :     std::mutex m;</a>
<a name="1020"><span class="lineNum">    1020 </span>            :     std::vector&lt;std::unique_ptr&lt;DetectedError&gt;&gt; uniqueResults;</a>
<a name="1021"><span class="lineNum">    1021 </span>            : </a>
<a name="1022"><span class="lineNum">    1022 </span>            :     /// &lt;summary&gt;</a>
<a name="1023"><span class="lineNum">    1023 </span>            :     /// Export statistics same for both fuzzers into a stream</a>
<a name="1024"><span class="lineNum">    1024 </span>            :     /// &lt;/summary&gt;</a>
<a name="1025"><span class="lineNum">    1025 </span><span class="lineCov">          4 :     void exportStatisticsCommon(std::ostream&amp; output)</span></a>
<a name="1026"><span class="lineNum">    1026 </span>            :     {</a>
<a name="1027"><span class="lineNum">    1027 </span><span class="lineCov">          4 :         std::lock_guard guard(m);</span></a>
<a name="1028"><span class="lineNum">    1028 </span>            :         output &lt;&lt;</a>
<a name="1029"><span class="lineNum">    1029 </span>            :             //&quot;{&quot;</a>
<a name="1030"><span class="lineNum">    1030 </span>            :                 &quot;\&quot;fuzzer_name\&quot;:&quot;              &quot;\&quot;kocoumat\&quot;,&quot;</a>
<a name="1031"><span class="lineNum">    1031 </span><span class="lineCov">          8 :                 &quot;\&quot;fuzzed_program\&quot;:&quot;           &quot;\&quot;&quot; ; escape(output, FUZZED_PROG.string())  &lt;&lt; &quot;\&quot;,&quot;</span></a>
<a name="1032"><span class="lineNum">    1032 </span><span class="lineCov">          4 :                 &quot;\&quot;nb_runs\&quot;:&quot; &lt;&lt; statisticsExecution.count() &lt;&lt; &quot;,&quot;</span></a>
<a name="1033"><span class="lineNum">    1033 </span><span class="lineCov">          8 :                 &quot;\&quot;nb_failed_runs\&quot;:&quot; &lt;&lt; nb_failed_runs.load(std::memory_order_relaxed) &lt;&lt; &quot;,&quot;</span></a>
<a name="1034"><span class="lineNum">    1034 </span><span class="lineCov">          8 :                 &quot;\&quot;nb_hanged_runs\&quot;:&quot; &lt;&lt; nb_hanged_runs.load(std::memory_order_relaxed) &lt;&lt; &quot;,&quot;</span></a>
<a name="1035"><span class="lineNum">    1035 </span>            :                 &quot;\&quot;execution_time\&quot;: {&quot;</a>
<a name="1036"><span class="lineNum">    1036 </span><span class="lineCov">          4 :                     &quot;\&quot;average\&quot;:&quot; &lt;&lt; statisticsExecution.avg() &lt;&lt; &quot;,&quot;</span></a>
<a name="1037"><span class="lineNum">    1037 </span><span class="lineCov">          4 :                     &quot;\&quot;median\&quot;:&quot; &lt;&lt; statisticsExecution.median() &lt;&lt; &quot;,&quot;</span></a>
<a name="1038"><span class="lineNum">    1038 </span><span class="lineCov">          4 :                     &quot;\&quot;min\&quot;:&quot; &lt;&lt; statisticsExecution.min() &lt;&lt; &quot;,&quot;</span></a>
<a name="1039"><span class="lineNum">    1039 </span><span class="lineCov">          4 :                     &quot;\&quot;max\&quot;:&quot; &lt;&lt; statisticsExecution.max() &lt;&lt;</span></a>
<a name="1040"><span class="lineNum">    1040 </span>            :                 &quot;},&quot;</a>
<a name="1041"><span class="lineNum">    1041 </span><span class="lineCov">          4 :                 &quot;\&quot;nb_unique_failures\&quot;:&quot; &lt;&lt; uniqueResults.size() &lt;&lt; &quot;,&quot;</span></a>
<a name="1042"><span class="lineNum">    1042 </span>            :                 &quot;\&quot;minimization\&quot;: {&quot;</a>
<a name="1043"><span class="lineNum">    1043 </span><span class="lineCov">          8 :                     &quot;\&quot;before\&quot;:&quot; &lt;&lt; nb_before_min.load(std::memory_order_relaxed) &lt;&lt; &quot;,&quot;</span></a>
<a name="1044"><span class="lineNum">    1044 </span><span class="lineCov">          4 :                     &quot;\&quot;avg_steps\&quot;:&quot; &lt;&lt; std::lround(statisticsMinimizationSteps.avg()) &lt;&lt; &quot;,&quot;</span></a>
<a name="1045"><span class="lineNum">    1045 </span>            :                     &quot;\&quot;execution_time\&quot;: {&quot;</a>
<a name="1046"><span class="lineNum">    1046 </span><span class="lineCov">          4 :                         &quot;\&quot;average\&quot;:&quot; &lt;&lt; statisticsMinimization.avg() &lt;&lt; &quot;,&quot;</span></a>
<a name="1047"><span class="lineNum">    1047 </span><span class="lineCov">          4 :                         &quot;\&quot;median\&quot;:&quot; &lt;&lt; statisticsMinimization.median() &lt;&lt; &quot;,&quot;</span></a>
<a name="1048"><span class="lineNum">    1048 </span><span class="lineCov">          4 :                         &quot;\&quot;min\&quot;:&quot; &lt;&lt; statisticsMinimization.min() &lt;&lt; &quot;,&quot;</span></a>
<a name="1049"><span class="lineNum">    1049 </span><span class="lineCov">          4 :                         &quot;\&quot;max\&quot;:&quot; &lt;&lt; statisticsMinimization.max() &lt;&lt;</span></a>
<a name="1050"><span class="lineNum">    1050 </span>            :                     &quot;}&quot;</a>
<a name="1051"><span class="lineNum">    1051 </span><span class="lineCov">          4 :                 &quot;}&quot;</span></a>
<a name="1052"><span class="lineNum">    1052 </span>            :             //&quot;}&quot;</a>
<a name="1053"><span class="lineNum">    1053 </span>            :             ;</a>
<a name="1054"><span class="lineNum">    1054 </span><span class="lineCov">          4 :     }</span></a>
<a name="1055"><span class="lineNum">    1055 </span>            : </a>
<a name="1056"><span class="lineNum">    1056 </span>            :     /// &lt;summary&gt;</a>
<a name="1057"><span class="lineNum">    1057 </span>            :     /// Export all statistics into a stream</a>
<a name="1058"><span class="lineNum">    1058 </span>            :     /// &lt;/summary&gt;</a>
<a name="1059"><span class="lineNum">    1059 </span>            :     /// &lt;param name=&quot;output&quot;&gt;&lt;/param&gt;</a>
<a name="1060"><span class="lineNum">    1060 </span>            :     virtual void exportStatistics(std::ostream&amp; output) = 0;</a>
<a name="1061"><span class="lineNum">    1061 </span>            : </a>
<a name="1062"><span class="lineNum">    1062 </span>            :     /// &lt;summary&gt;</a>
<a name="1063"><span class="lineNum">    1063 </span>            :     /// Save stats into a file</a>
<a name="1064"><span class="lineNum">    1064 </span>            :     /// &lt;/summary&gt;</a>
<a name="1065"><span class="lineNum">    1065 </span><span class="lineCov">          2 :     void saveStatistics()</span></a>
<a name="1066"><span class="lineNum">    1066 </span>            :     {</a>
<a name="1067"><span class="lineNum">    1067 </span><span class="lineCov">          2 :         auto path = RESULT_FUZZ / &quot;stats.json&quot;;</span></a>
<a name="1068"><span class="lineNum">    1068 </span>            :         //std::cerr &lt;&lt; &quot;Saving statistics to &quot; &lt;&lt; path &lt;&lt; std::endl;</a>
<a name="1069"><span class="lineNum">    1069 </span>            : </a>
<a name="1070"><span class="lineNum">    1070 </span><span class="lineCov">          2 :         std::ofstream output(path);</span></a>
<a name="1071"><span class="lineNum">    1071 </span><span class="lineCov">          2 :         exportStatistics(output);</span></a>
<a name="1072"><span class="lineNum">    1072 </span>            : </a>
<a name="1073"><span class="lineNum">    1073 </span><span class="lineCov">          2 :         std::cout &lt;&lt; &quot;Current stats: \n&quot;;</span></a>
<a name="1074"><span class="lineNum">    1074 </span><span class="lineCov">          2 :         exportStatistics(std::cout);</span></a>
<a name="1075"><span class="lineNum">    1075 </span><span class="lineCov">          2 :         std::cout &lt;&lt; std::endl;</span></a>
<a name="1076"><span class="lineNum">    1076 </span>            : </a>
<a name="1077"><span class="lineNum">    1077 </span><span class="lineCov">          2 :         if (!output)</span></a>
<a name="1078"><span class="lineNum">    1078 </span><span class="lineNoCov">          0 :             std::cerr &lt;&lt; &quot;Error saving statistics!&quot; &lt;&lt; std::endl;</span></a>
<a name="1079"><span class="lineNum">    1079 </span><span class="lineCov">          2 :     }</span></a>
<a name="1080"><span class="lineNum">    1080 </span>            : </a>
<a name="1081"><span class="lineNum">    1081 </span>            :     /// &lt;summary&gt;</a>
<a name="1082"><span class="lineNum">    1082 </span>            :     /// Checks whether error is present in runner output and do appropriate actions with it</a>
<a name="1083"><span class="lineNum">    1083 </span>            :     /// &lt;/summary&gt;</a>
<a name="1084"><span class="lineNum">    1084 </span>            :     /// &lt;param name=&quot;input&quot;&gt;Input string that was ran by the runner&lt;/param&gt;</a>
<a name="1085"><span class="lineNum">    1085 </span>            :     /// &lt;param name=&quot;result&quot;&gt;Result of the runner&lt;/param&gt;</a>
<a name="1086"><span class="lineNum">    1086 </span>            :     /// &lt;param name=&quot;executionInput&quot;&gt;Where to test inputs&lt;/param&gt;</a>
<a name="1087"><span class="lineNum">    1087 </span>            :     /// &lt;param name=&quot;fromMin&quot;&gt;Is this random or from minimization&lt;/param&gt;</a>
<a name="1088"><span class="lineNum">    1088 </span>            :     /// &lt;returns&gt;Pointer to erorr if occured. Owned by result vector. Do not free!&lt;/returns&gt;</a>
<a name="1089"><span class="lineNum">    1089 </span><span class="lineCov">          2 :     DetectedError* dealWithResult(const std::string_view&amp; input, ExecutionResult result, ExecutionInput&amp; executionInput, bool fromMin = false)</span></a>
<a name="1090"><span class="lineNum">    1090 </span>            :     {</a>
<a name="1091"><span class="lineNum">    1091 </span><span class="lineCov">          2 :         CrashReport report;</span></a>
<a name="1092"><span class="lineNum">    1092 </span>            :         size_t errorCount;</a>
<a name="1093"><span class="lineNum">    1093 </span>            :         {</a>
<a name="1094"><span class="lineNum">    1094 </span><span class="lineCov">          2 :             auto err = detectError(result);</span></a>
<a name="1095"><span class="lineNum">    1095 </span>            : </a>
<a name="1096"><span class="lineNum">    1096 </span><span class="lineCov">          2 :             if (err == nullptr)</span></a>
<a name="1097"><span class="lineNum">    1097 </span><span class="lineNoCov">          0 :                 return nullptr; //OK, no error</span></a>
<a name="1098"><span class="lineNum">    1098 </span>            : </a>
<a name="1099"><span class="lineNum">    1099 </span>            :             {</a>
<a name="1100"><span class="lineNum">    1100 </span><span class="lineCov">          2 :                 std::unique_lock lock(m);</span></a>
<a name="1101"><span class="lineNum">    1101 </span><span class="lineCov">          2 :                 errorCount = uniqueResults.size();</span></a>
<a name="1102"><span class="lineNum">    1102 </span><span class="lineCov">          2 :                 for (size_t i = 0; i &lt; uniqueResults.size(); i++)</span></a>
<a name="1103"><span class="lineNum">    1103 </span>            :                 {</a>
<a name="1104"><span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                     if (*err == *uniqueResults[i])//Error already logged</span></a>
<a name="1105"><span class="lineNum">    1105 </span>            :                     {</a>
<a name="1106"><span class="lineNum">    1106 </span>            :                         //std::cerr &lt;&lt; &quot;This error was already found, nothing new&quot; &lt;&lt; std::endl;</a>
<a name="1107"><span class="lineNum">    1107 </span><span class="lineNoCov">          0 :                         return uniqueResults[i].get();</span></a>
<a name="1108"><span class="lineNum">    1108 </span>            :                     }</a>
<a name="1109"><span class="lineNum">    1109 </span>            : </a>
<a name="1110"><span class="lineNum">    1110 </span>            :                 }</a>
<a name="1111"><span class="lineNum">    1111 </span>            :                 //std::cerr &lt;&lt; &quot;Detected new error &quot; &lt;&lt; err-&gt;errorName() &lt;&lt; &quot; for input &quot; &lt;&lt; pop.first &lt;&lt; std::endl;</a>
<a name="1112"><span class="lineNum">    1112 </span><span class="lineCov">          2 :                 uniqueResults.push_back(std::move(err));</span></a>
<a name="1113"><span class="lineNum">    1113 </span>            : </a>
<a name="1114"><span class="lineNum">    1114 </span><span class="lineCov">          2 :                 if (uniqueResults.size() &gt;= NB_KNOWN_BUGS)</span></a>
<a name="1115"><span class="lineNum">    1115 </span><span class="lineCov">          2 :                     keepRunning = false;</span></a>
<a name="1116"><span class="lineNum">    1116 </span><span class="lineCov">          2 :             }</span></a>
<a name="1117"><span class="lineNum">    1117 </span><span class="lineCov">          2 :         }</span></a>
<a name="1118"><span class="lineNum">    1118 </span>            : </a>
<a name="1119"><span class="lineNum">    1119 </span><span class="lineCov">          2 :         if (!fromMin) // this was generated by random, not discovered while minimizing</span></a>
<a name="1120"><span class="lineNum">    1120 </span><span class="lineCov">          2 :             nb_before_min.fetch_add(1, std::memory_order_relaxed);</span></a>
<a name="1121"><span class="lineNum">    1121 </span>            : </a>
<a name="1122"><span class="lineNum">    1122 </span><span class="lineCov">          2 :         report.nb_steps = 0;</span></a>
<a name="1123"><span class="lineNum">    1123 </span><span class="lineCov">          2 :         report.unminimized_size = input.size();</span></a>
<a name="1124"><span class="lineNum">    1124 </span>            : </a>
<a name="1125"><span class="lineNum">    1125 </span><span class="lineCov">          2 :         report.execution_time = result.execution_time;</span></a>
<a name="1126"><span class="lineNum">    1126 </span><span class="lineCov">          2 :         report.detectedError = uniqueResults[errorCount].get();</span></a>
<a name="1127"><span class="lineNum">    1127 </span>            : </a>
<a name="1128"><span class="lineNum">    1128 </span><span class="lineCov">          2 :         report.minimization_time = std::chrono::milliseconds(0);</span></a>
<a name="1129"><span class="lineNum">    1129 </span>            : </a>
<a name="1130"><span class="lineNum">    1130 </span><span class="lineCov">          2 :         if (MINIMIZE)</span></a>
<a name="1131"><span class="lineNum">    1131 </span>            :         {</a>
<a name="1132"><span class="lineNum">    1132 </span><span class="lineCov">          2 :             auto start = std::chrono::high_resolution_clock::now();</span></a>
<a name="1133"><span class="lineNum">    1133 </span><span class="lineCov">          2 :             report.input = minimizeInput(input, *report.detectedError, executionInput, report.nb_steps);</span></a>
<a name="1134"><span class="lineNum">    1134 </span><span class="lineCov">          2 :             auto end = std::chrono::high_resolution_clock::now();</span></a>
<a name="1135"><span class="lineNum">    1135 </span>            : </a>
<a name="1136"><span class="lineNum">    1136 </span><span class="lineCov">          2 :             report.minimization_time = std::chrono::duration_cast&lt;std::chrono::duration&lt;double, std::milli&gt;&gt;(end - start);</span></a>
<a name="1137"><span class="lineNum">    1137 </span>            : </a>
<a name="1138"><span class="lineNum">    1138 </span><span class="lineCov">          2 :             statisticsMinimization.addNumber(report.minimization_time.count());</span></a>
<a name="1139"><span class="lineNum">    1139 </span><span class="lineCov">          2 :             statisticsMinimizationSteps.addNumber(report.nb_steps);</span></a>
<a name="1140"><span class="lineNum">    1140 </span>            :         }</a>
<a name="1141"><span class="lineNum">    1141 </span>            :         else</a>
<a name="1142"><span class="lineNum">    1142 </span><span class="lineNoCov">          0 :             report.input = input;</span></a>
<a name="1143"><span class="lineNum">    1143 </span>            : </a>
<a name="1144"><span class="lineNum">    1144 </span>            : </a>
<a name="1145"><span class="lineNum">    1145 </span><span class="lineCov">          2 :         saveReport(report, std::to_string(errorCount) + &quot;.json&quot;, RESULT_FUZZ);</span></a>
<a name="1146"><span class="lineNum">    1146 </span><span class="lineCov">          2 :         return report.detectedError;</span></a>
<a name="1147"><span class="lineNum">    1147 </span><span class="lineCov">          2 :     }</span></a>
<a name="1148"><span class="lineNum">    1148 </span>            : </a>
<a name="1149"><span class="lineNum">    1149 </span>            :     virtual void fuzz() = 0;</a>
<a name="1150"><span class="lineNum">    1150 </span>            : </a>
<a name="1151"><span class="lineNum">    1151 </span>            : </a>
<a name="1152"><span class="lineNum">    1152 </span>            :     std::unique_ptr&lt;ExecutionInput&gt; executionInput;</a>
<a name="1153"><span class="lineNum">    1153 </span>            : </a>
<a name="1154"><span class="lineNum">    1154 </span>            : public:</a>
<a name="1155"><span class="lineNum">    1155 </span><span class="lineCov">          8 :     fuzzer(std::filesystem::path FUZZED_PROG, std::filesystem::path RESULT_FUZZ, bool MINIMIZE, std::string_view fuzzInputType, std::chrono::seconds TIMEOUT, size_t NB_KNOWN_BUGS) : FUZZED_PROG(FUZZED_PROG), RESULT_FUZZ(RESULT_FUZZ), MINIMIZE(MINIMIZE), fuzzInputType(fuzzInputType), TIMEOUT(TIMEOUT), NB_KNOWN_BUGS(NB_KNOWN_BUGS)//, minSize(minSize), maxSize(maxSize)</span></a>
<a name="1156"><span class="lineNum">    1156 </span>            :     {</a>
<a name="1157"><span class="lineNum">    1157 </span><span class="lineCov">          8 :         if (!std::filesystem::exists(this-&gt;FUZZED_PROG) || std::filesystem::is_directory(this-&gt;FUZZED_PROG))</span></a>
<a name="1158"><span class="lineNum">    1158 </span><span class="lineNoCov">          0 :             throw std::runtime_error(&quot;Program to fuzz does not exist&quot;);</span></a>
<a name="1159"><span class="lineNum">    1159 </span>            : </a>
<a name="1160"><span class="lineNum">    1160 </span><span class="lineCov">          8 :         std::filesystem::create_directories(RESULT_FUZZ);</span></a>
<a name="1161"><span class="lineNum">    1161 </span><span class="lineCov">          8 :         std::filesystem::create_directories(RESULT_FUZZ / &quot;crashes&quot;);</span></a>
<a name="1162"><span class="lineNum">    1162 </span><span class="lineCov">          8 :         std::filesystem::create_directories(RESULT_FUZZ / &quot;hangs&quot;);</span></a>
<a name="1163"><span class="lineNum">    1163 </span>            : </a>
<a name="1164"><span class="lineNum">    1164 </span><span class="lineCov">          8 :         constexpr std::chrono::milliseconds timeout = std::chrono::seconds(5);</span></a>
<a name="1165"><span class="lineNum">    1165 </span>            : </a>
<a name="1166"><span class="lineNum">    1166 </span><span class="lineCov">          8 :         if (fuzzInputType == &quot;stdin&quot;)</span></a>
<a name="1167"><span class="lineNum">    1167 </span>            :         {</a>
<a name="1168"><span class="lineNum">    1168 </span>            :             //std::cerr &lt;&lt; &quot;Using cin as input&quot; &lt;&lt; std::endl;</a>
<a name="1169"><span class="lineNum">    1169 </span><span class="lineCov">          5 :             executionInput = std::make_unique&lt;CinInput&gt;(FUZZED_PROG, timeout);</span></a>
<a name="1170"><span class="lineNum">    1170 </span>            :         }</a>
<a name="1171"><span class="lineNum">    1171 </span>            :         else</a>
<a name="1172"><span class="lineNum">    1172 </span>            :         {</a>
<a name="1173"><span class="lineNum">    1173 </span>            :             //std::cerr &lt;&lt; &quot;Using file as input&quot; &lt;&lt; std::endl;</a>
<a name="1174"><span class="lineNum">    1174 </span><span class="lineCov">          3 :             executionInput = std::make_unique&lt;FileInput&gt;(FUZZED_PROG, timeout, std::string(fuzzInputType));</span></a>
<a name="1175"><span class="lineNum">    1175 </span>            :         }</a>
<a name="1176"><span class="lineNum">    1176 </span><span class="lineCov">          8 :     }</span></a>
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<a name="1178"><span class="lineNum">    1178 </span>            :     /// &lt;summary&gt;</a>
<a name="1179"><span class="lineNum">    1179 </span>            :     /// Run the fuzzer (blocking call)</a>
<a name="1180"><span class="lineNum">    1180 </span>            :     /// &lt;/summary&gt;</a>
<a name="1181"><span class="lineNum">    1181 </span><span class="lineCov">          2 :     void run()</span></a>
<a name="1182"><span class="lineNum">    1182 </span>            :     {</a>
<a name="1183"><span class="lineNum">    1183 </span><span class="lineCov">          2 :         currentAsanOffset = asanOffset();</span></a>
<a name="1184"><span class="lineNum">    1184 </span>            : </a>
<a name="1185"><span class="lineNum">    1185 </span><span class="lineCov">          2 :         std::atomic&lt;bool&gt; threadsRunning = true;</span></a>
<a name="1186"><span class="lineNum">    1186 </span>            : </a>
<a name="1187"><span class="lineNum">    1187 </span>            :         // Thread for updating the stats in real-time</a>
<a name="1188"><span class="lineNum">    1188 </span><span class="lineCov">          2 :         std::jthread updateStats([&amp;]() {</span></a>
<a name="1189"><span class="lineNum">    1189 </span><span class="lineCov">          2 :             uint8_t counter = 0;</span></a>
<a name="1190"><span class="lineNum">    1190 </span><span class="lineCov">          4 :             while (threadsRunning)</span></a>
<a name="1191"><span class="lineNum">    1191 </span>            :             {</a>
<a name="1192"><span class="lineNum">    1192 </span><span class="lineCov">          2 :                 if (counter++ == 10)</span></a>
<a name="1193"><span class="lineNum">    1193 </span>            :                 {</a>
<a name="1194"><span class="lineNum">    1194 </span><span class="lineNoCov">          0 :                     counter = 0;</span></a>
<a name="1195"><span class="lineNum">    1195 </span><span class="lineNoCov">          0 :                     saveStatistics();</span></a>
<a name="1196"><span class="lineNum">    1196 </span>            :                 }</a>
<a name="1197"><span class="lineNum">    1197 </span><span class="lineCov">          2 :                 std::this_thread::sleep_for(std::chrono::seconds(1));</span></a>
<a name="1198"><span class="lineNum">    1198 </span>            :             }</a>
<a name="1199"><span class="lineNum">    1199 </span><span class="lineCov">          2 :             std::cerr &lt;&lt; &quot;Program can end, writing one last statistics report and exiting...&quot; &lt;&lt; std::endl;</span></a>
<a name="1200"><span class="lineNum">    1200 </span><span class="lineCov">          2 :             saveStatistics();</span></a>
<a name="1201"><span class="lineNum">    1201 </span><span class="lineCov">          4 :             });</span></a>
<a name="1202"><span class="lineNum">    1202 </span>            : </a>
<a name="1203"><span class="lineNum">    1203 </span>            :         // Thread for terminating the process if it runs for too long</a>
<a name="1204"><span class="lineNum">    1204 </span><span class="lineCov">          2 :         std::jthread timeoutThread([&amp;]() {</span></a>
<a name="1205"><span class="lineNum">    1205 </span><span class="lineCov">          2 :             const auto start = std::chrono::high_resolution_clock::now();</span></a>
<a name="1206"><span class="lineNum">    1206 </span><span class="lineCov">          2 :             const auto timeout = TIMEOUT - std::chrono::seconds(1);</span></a>
<a name="1207"><span class="lineNum">    1207 </span><span class="lineCov">          4 :             while (std::chrono::duration_cast&lt;std::chrono::seconds&gt;(std::chrono::high_resolution_clock::now() - start) &lt; timeout &amp;&amp; keepRunning)</span></a>
<a name="1208"><span class="lineNum">    1208 </span>            :             {</a>
<a name="1209"><span class="lineNum">    1209 </span><span class="lineCov">          2 :                 std::this_thread::sleep_for(std::chrono::seconds(1)); // Wait for the set time</span></a>
<a name="1210"><span class="lineNum">    1210 </span>            :             }</a>
<a name="1211"><span class="lineNum">    1211 </span>            :             </a>
<a name="1212"><span class="lineNum">    1212 </span><span class="lineCov">          2 :             keepRunning = false;</span></a>
<a name="1213"><span class="lineNum">    1213 </span><span class="lineCov">          2 :             std::cerr &lt;&lt; &quot;Timeout reached or everything found, ending.&quot; &lt;&lt; std::endl;</span></a>
<a name="1214"><span class="lineNum">    1214 </span><span class="lineCov">          4 :             });</span></a>
<a name="1215"><span class="lineNum">    1215 </span>            : </a>
<a name="1216"><span class="lineNum">    1216 </span>            :         try</a>
<a name="1217"><span class="lineNum">    1217 </span>            :         {</a>
<a name="1218"><span class="lineNum">    1218 </span>            :             // Run the actual fuzzing. Ready for multiple threads of execution, but not implemented.</a>
<a name="1219"><span class="lineNum">    1219 </span>            : </a>
<a name="1220"><span class="lineNum">    1220 </span><span class="lineCov">          2 :             std::vector&lt;std::jthread&gt; threads;</span></a>
<a name="1221"><span class="lineNum">    1221 </span><span class="lineCov">          2 :             auto threadCount = 1;// std::thread::hardware_concurrency();</span></a>
<a name="1222"><span class="lineNum">    1222 </span>            : </a>
<a name="1223"><span class="lineNum">    1223 </span><span class="lineCov">          2 :             std::cerr &lt;&lt; &quot;Running &quot; &lt;&lt; threadCount &lt;&lt; &quot; fuzzers&quot; &lt;&lt; std::endl;</span></a>
<a name="1224"><span class="lineNum">    1224 </span>            : </a>
<a name="1225"><span class="lineNum">    1225 </span>            :             //threads.reserve(threadCount - 1);</a>
<a name="1226"><span class="lineNum">    1226 </span>            :             //for (size_t i = 0; i &lt; threadCount - 1; i++)</a>
<a name="1227"><span class="lineNum">    1227 </span>            :             //    threads.emplace_back(fuzz, this);</a>
<a name="1228"><span class="lineNum">    1228 </span>            : </a>
<a name="1229"><span class="lineNum">    1229 </span><span class="lineCov">          2 :             fuzz();</span></a>
<a name="1230"><span class="lineNum">    1230 </span><span class="lineCov">          2 :         }</span></a>
<a name="1231"><span class="lineNum">    1231 </span><span class="lineNoCov">          0 :         catch (const std::exception&amp; e)</span></a>
<a name="1232"><span class="lineNum">    1232 </span>            :         {</a>
<a name="1233"><span class="lineNum">    1233 </span><span class="lineNoCov">          0 :             std::cerr &lt;&lt; &quot;ERROR: &quot; &lt;&lt; e.what() &lt;&lt; std::endl;</span></a>
<a name="1234"><span class="lineNum">    1234 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="1235"><span class="lineNum">    1235 </span>            : </a>
<a name="1236"><span class="lineNum">    1236 </span><span class="lineCov">          2 :         std::cerr &lt;&lt; &quot;All fuzzers done, ready to exit&quot; &lt;&lt; std::endl;</span></a>
<a name="1237"><span class="lineNum">    1237 </span><span class="lineCov">          2 :         threadsRunning = false;</span></a>
<a name="1238"><span class="lineNum">    1238 </span><span class="lineCov">          2 :     }</span></a>
<a name="1239"><span class="lineNum">    1239 </span>            : </a>
<a name="1240"><span class="lineNum">    1240 </span>            :     void requestStop()</a>
<a name="1241"><span class="lineNum">    1241 </span>            :     {</a>
<a name="1242"><span class="lineNum">    1242 </span>            :         keepRunning = false;</a>
<a name="1243"><span class="lineNum">    1243 </span>            :     }</a>
<a name="1244"><span class="lineNum">    1244 </span>            : </a>
<a name="1245"><span class="lineNum">    1245 </span>            : };</a>
<a name="1246"><span class="lineNum">    1246 </span>            : </a>
<a name="1247"><span class="lineNum">    1247 </span>            : /// &lt;summary&gt;</a>
<a name="1248"><span class="lineNum">    1248 </span>            : /// Fuzzer that does not have any information about the file it is fuzzing</a>
<a name="1249"><span class="lineNum">    1249 </span>            : /// &lt;/summary&gt;</a>
<a name="1250"><span class="lineNum">    1250 </span>            : struct fuzzer_blackbox : public fuzzer</a>
<a name="1251"><span class="lineNum">    1251 </span>            : {</a>
<a name="1252"><span class="lineNum">    1252 </span>            :     /// &lt;summary&gt;</a>
<a name="1253"><span class="lineNum">    1253 </span>            :     /// Fuzzer that does not have any information about the file it is fuzzing</a>
<a name="1254"><span class="lineNum">    1254 </span>            :     /// &lt;/summary&gt;</a>
<a name="1255"><span class="lineNum">    1255 </span>            :     /// &lt;param name=&quot;FUZZED_PROG&quot;&gt;Path to the executable the fuzzer will be running&lt;/param&gt;</a>
<a name="1256"><span class="lineNum">    1256 </span>            :     /// &lt;param name=&quot;RESULT_FUZZ&quot;&gt;Path to a folder where crashes will be saved&lt;/param&gt;</a>
<a name="1257"><span class="lineNum">    1257 </span>            :     /// &lt;param name=&quot;MINIMIZE&quot;&gt;If the fuzzer should minimize crashing inputs&lt;/param&gt;</a>
<a name="1258"><span class="lineNum">    1258 </span>            :     /// &lt;param name=&quot;INPUT&quot;&gt;Input method for given executable. &quot;stdin&quot; if through standard input, file name otherwise.&lt;/param&gt;</a>
<a name="1259"><span class="lineNum">    1259 </span>            :     /// &lt;param name=&quot;TIMEOUT&quot;&gt;Time passed before the fuzzer is stopped&lt;/param&gt;</a>
<a name="1260"><span class="lineNum">    1260 </span>            :     /// &lt;param name=&quot;NB_KNOWN_BUGS&quot;&gt;After the fuzzer finds this many bugs, it terminates.&lt;/param&gt;</a>
<a name="1261"><span class="lineNum">    1261 </span><span class="lineCov">          6 :     fuzzer_blackbox(std::filesystem::path FUZZED_PROG, std::filesystem::path RESULT_FUZZ, bool MINIMIZE, std::string_view INPUT, std::chrono::seconds TIMEOUT, size_t NB_KNOWN_BUGS/*, size_t minSize = 1, size_t maxSize = 1024*/) : fuzzer(std::move(FUZZED_PROG), std::move(RESULT_FUZZ), std::move(MINIMIZE), std::move(INPUT), std::move(TIMEOUT), std::move(NB_KNOWN_BUGS))//, minSize(minSize), maxSize(maxSize)</span></a>
<a name="1262"><span class="lineNum">    1262 </span>            :     {</a>
<a name="1263"><span class="lineNum">    1263 </span>            : </a>
<a name="1264"><span class="lineNum">    1264 </span><span class="lineCov">          6 :     }</span></a>
<a name="1265"><span class="lineNum">    1265 </span>            : </a>
<a name="1266"><span class="lineNum">    1266 </span><span class="lineCov">          1 :     virtual size_t asanOffset() const override</span></a>
<a name="1267"><span class="lineNum">    1267 </span>            :     {</a>
<a name="1268"><span class="lineNum">    1268 </span><span class="lineCov">          1 :         return 0;</span></a>
<a name="1269"><span class="lineNum">    1269 </span>            :     }</a>
<a name="1270"><span class="lineNum">    1270 </span>            : </a>
<a name="1271"><span class="lineNum">    1271 </span><span class="lineCov">          1 :     virtual void fuzz() override</span></a>
<a name="1272"><span class="lineNum">    1272 </span>            :     {</a>
<a name="1273"><span class="lineNum">    1273 </span><span class="lineCov">          2 :         while (keepRunning)</span></a>
<a name="1274"><span class="lineNum">    1274 </span>            :         {</a>
<a name="1275"><span class="lineNum">    1275 </span><span class="lineCov">          1 :             auto input = generators::generateRandomInput();</span></a>
<a name="1276"><span class="lineNum">    1276 </span>            : </a>
<a name="1277"><span class="lineNum">    1277 </span><span class="lineCov">          1 :             executionInput-&gt;setInput(input);</span></a>
<a name="1278"><span class="lineNum">    1278 </span>            : </a>
<a name="1279"><span class="lineNum">    1279 </span><span class="lineCov">          1 :             auto res = execute_with_timeout(*executionInput);</span></a>
<a name="1280"><span class="lineNum">    1280 </span>            : </a>
<a name="1281"><span class="lineNum">    1281 </span><span class="lineCov">          1 :             dealWithResult(input, std::move(res), *executionInput, false);</span></a>
<a name="1282"><span class="lineNum">    1282 </span><span class="lineCov">          1 :         }</span></a>
<a name="1283"><span class="lineNum">    1283 </span>            :         //std::cerr &lt;&lt; &quot;Exiting fuzzer&quot; &lt;&lt; std::endl;</a>
<a name="1284"><span class="lineNum">    1284 </span><span class="lineCov">          1 :     }</span></a>
<a name="1285"><span class="lineNum">    1285 </span>            : </a>
<a name="1286"><span class="lineNum">    1286 </span><span class="lineCov">          2 :     virtual void exportStatistics(std::ostream&amp; out) override</span></a>
<a name="1287"><span class="lineNum">    1287 </span>            :     {</a>
<a name="1288"><span class="lineNum">    1288 </span><span class="lineCov">          2 :         out &lt;&lt; '{';</span></a>
<a name="1289"><span class="lineNum">    1289 </span><span class="lineCov">          2 :         exportStatisticsCommon(out);</span></a>
<a name="1290"><span class="lineNum">    1290 </span><span class="lineCov">          2 :         out &lt;&lt; '}';</span></a>
<a name="1291"><span class="lineNum">    1291 </span><span class="lineCov">          2 :     }</span></a>
<a name="1292"><span class="lineNum">    1292 </span>            : </a>
<a name="1293"><span class="lineNum">    1293 </span><span class="lineCov">          5 :     virtual void exportReport(const CrashReport&amp; report, std::ostream&amp; out) const override</span></a>
<a name="1294"><span class="lineNum">    1294 </span>            :     {</a>
<a name="1295"><span class="lineNum">    1295 </span><span class="lineCov">          5 :         out &lt;&lt; '{';</span></a>
<a name="1296"><span class="lineNum">    1296 </span><span class="lineCov">          5 :         exportReportCommon(report, out);</span></a>
<a name="1297"><span class="lineNum">    1297 </span><span class="lineCov">          5 :         out &lt;&lt; '}';</span></a>
<a name="1298"><span class="lineNum">    1298 </span><span class="lineCov">          5 :     }</span></a>
<a name="1299"><span class="lineNum">    1299 </span>            : };</a>
<a name="1300"><span class="lineNum">    1300 </span>            : </a>
<a name="1301"><span class="lineNum">    1301 </span>            : /// &lt;summary&gt;</a>
<a name="1302"><span class="lineNum">    1302 </span>            : /// Load the whole file into a string</a>
<a name="1303"><span class="lineNum">    1303 </span>            : /// &lt;/summary&gt;</a>
<a name="1304"><span class="lineNum">    1304 </span>            : /// &lt;param name=&quot;path&quot;&gt;Path to the file&lt;/param&gt;</a>
<a name="1305"><span class="lineNum">    1305 </span>            : /// &lt;returns&gt;Contents of given file&lt;/returns&gt;</a>
<a name="1306"><span class="lineNum">    1306 </span><span class="lineCov">          1 : static std::string loadFile(const std::filesystem::path&amp; path)</span></a>
<a name="1307"><span class="lineNum">    1307 </span>            : {</a>
<a name="1308"><span class="lineNum">    1308 </span><span class="lineCov">          1 :     auto file = std::ifstream(path, std::ios::binary);</span></a>
<a name="1309"><span class="lineNum">    1309 </span>            : </a>
<a name="1310"><span class="lineNum">    1310 </span><span class="lineCov">          1 :     if (!file.is_open()) [[unlikely]]</span></a>
<a name="1311"><span class="lineNum">    1311 </span><span class="lineNoCov">          0 :         throw std::runtime_error(&quot;Cannot open file: &quot; + path.string());</span></a>
<a name="1312"><span class="lineNum">    1312 </span>            : </a>
<a name="1313"><span class="lineNum">    1313 </span><span class="lineCov">          1 :     std::string res;</span></a>
<a name="1314"><span class="lineNum">    1314 </span><span class="lineCov">          1 :     file.seekg(0, std::ios::end);</span></a>
<a name="1315"><span class="lineNum">    1315 </span><span class="lineCov">          1 :     res.resize(file.tellg());</span></a>
<a name="1316"><span class="lineNum">    1316 </span><span class="lineCov">          1 :     file.seekg(0, std::ios::beg);</span></a>
<a name="1317"><span class="lineNum">    1317 </span><span class="lineCov">          1 :     file.read(&amp;res[0], res.size());</span></a>
<a name="1318"><span class="lineNum">    1318 </span>            : </a>
<a name="1319"><span class="lineNum">    1319 </span><span class="lineCov">          1 :     if (file.fail()) [[unlikely]]</span></a>
<a name="1320"><span class="lineNum">    1320 </span><span class="lineNoCov">          0 :         throw std::runtime_error(&quot;Error reading file: &quot; + path.string());</span></a>
<a name="1321"><span class="lineNum">    1321 </span>            : </a>
<a name="1322"><span class="lineNum">    1322 </span><span class="lineCov">          2 :     return res;</span></a>
<a name="1323"><span class="lineNum">    1323 </span><span class="lineCov">          1 : }</span></a>
<a name="1324"><span class="lineNum">    1324 </span>            : </a>
<a name="1325"><span class="lineNum">    1325 </span>            : /// &lt;summary&gt;</a>
<a name="1326"><span class="lineNum">    1326 </span>            : /// Fuzzer that works with source code of fuzzing file</a>
<a name="1327"><span class="lineNum">    1327 </span>            : /// &lt;/summary&gt;</a>
<a name="1328"><span class="lineNum">    1328 </span>            : struct fuzzer_greybox : public fuzzer</a>
<a name="1329"><span class="lineNum">    1329 </span>            : {</a>
<a name="1330"><span class="lineNum">    1330 </span>            :     typedef std::vector&lt;bool&gt; coveragePath;</a>
<a name="1331"><span class="lineNum">    1331 </span>            : </a>
<a name="1332"><span class="lineNum">    1332 </span><span class="lineCov">          1 :     virtual size_t asanOffset() const override</span></a>
<a name="1333"><span class="lineNum">    1333 </span>            :     {</a>
<a name="1334"><span class="lineNum">    1334 </span><span class="lineCov">          1 :         return 4; // Our tool has this offset</span></a>
<a name="1335"><span class="lineNum">    1335 </span>            :     }</a>
<a name="1336"><span class="lineNum">    1336 </span>            : </a>
<a name="1337"><span class="lineNum">    1337 </span>            :     enum class POWER_SCHEDULE_T : uint8_t</a>
<a name="1338"><span class="lineNum">    1338 </span>            :     {</a>
<a name="1339"><span class="lineNum">    1339 </span>            :         simple,</a>
<a name="1340"><span class="lineNum">    1340 </span>            :         boosted</a>
<a name="1341"><span class="lineNum">    1341 </span>            :     };</a>
<a name="1342"><span class="lineNum">    1342 </span>            : </a>
<a name="1343"><span class="lineNum">    1343 </span>            :     /// &lt;summary&gt;</a>
<a name="1344"><span class="lineNum">    1344 </span>            :     /// Seed that fuzzer keeps in queue</a>
<a name="1345"><span class="lineNum">    1345 </span>            :     /// &lt;/summary&gt;</a>
<a name="1346"><span class="lineNum">    1346 </span>            :     struct seed</a>
<a name="1347"><span class="lineNum">    1347 </span>            :     {</a>
<a name="1348"><span class="lineNum">    1348 </span><span class="lineCov">          5 :         seed(std::string input) : input(std::move(input)) {};</span></a>
<a name="1349"><span class="lineNum">    1349 </span>            :         const std::string input;</a>
<a name="1350"><span class="lineNum">    1350 </span>            : </a>
<a name="1351"><span class="lineNum">    1351 </span>            :         /// &lt;summary&gt;</a>
<a name="1352"><span class="lineNum">    1352 </span>            :         /// Increment the counter for this seed counting how many times it was selected (if needed)</a>
<a name="1353"><span class="lineNum">    1353 </span>            :         /// &lt;/summary&gt;</a>
<a name="1354"><span class="lineNum">    1354 </span>            :         virtual void incrementSelected() = 0;</a>
<a name="1355"><span class="lineNum">    1355 </span>            :         /// &lt;summary&gt;</a>
<a name="1356"><span class="lineNum">    1356 </span>            :         /// Increment the counter for this seed counting how many times it improved the coverage (if needed)</a>
<a name="1357"><span class="lineNum">    1357 </span>            :         /// &lt;/summary&gt;</a>
<a name="1358"><span class="lineNum">    1358 </span>            :         virtual void incrementImproved() = 0;</a>
<a name="1359"><span class="lineNum">    1359 </span>            :         /// &lt;summary&gt;</a>
<a name="1360"><span class="lineNum">    1360 </span>            :         /// Update the energy of this seed from set information.</a>
<a name="1361"><span class="lineNum">    1361 </span>            :         /// &lt;/summary&gt;</a>
<a name="1362"><span class="lineNum">    1362 </span>            :         virtual void update() = 0;</a>
<a name="1363"><span class="lineNum">    1363 </span><span class="lineCov">          6 :         virtual ~seed() = default;</span></a>
<a name="1364"><span class="lineNum">    1364 </span>            :     };</a>
<a name="1365"><span class="lineNum">    1365 </span>            : </a>
<a name="1366"><span class="lineNum">    1366 </span>            :     struct seedSimple : public seed</a>
<a name="1367"><span class="lineNum">    1367 </span>            :     {</a>
<a name="1368"><span class="lineNum">    1368 </span>            :         double e; //energy</a>
<a name="1369"><span class="lineNum">    1369 </span>            : </a>
<a name="1370"><span class="lineNum">    1370 </span>            :         const double T; // execution time</a>
<a name="1371"><span class="lineNum">    1371 </span>            :         size_t nm; // how many times it was already selected to be mutated</a>
<a name="1372"><span class="lineNum">    1372 </span>            :         size_t nc; // how many times it led to an increase in coverage</a>
<a name="1373"><span class="lineNum">    1373 </span>            : </a>
<a name="1374"><span class="lineNum">    1374 </span>            :         /// &lt;summary&gt;</a>
<a name="1375"><span class="lineNum">    1375 </span>            :         /// Seed for the simple power method</a>
<a name="1376"><span class="lineNum">    1376 </span>            :         /// &lt;/summary&gt;</a>
<a name="1377"><span class="lineNum">    1377 </span>            :         /// &lt;param name=&quot;input&quot;&gt;String that should be associated with this seed&lt;/param&gt;</a>
<a name="1378"><span class="lineNum">    1378 </span>            :         /// &lt;param name=&quot;T&quot;&gt;Time it took to execute this seed&lt;/param&gt;</a>
<a name="1379"><span class="lineNum">    1379 </span>            :         /// &lt;param name=&quot;nm&quot;&gt;How many times it was already selected to be mutated&lt;/param&gt;</a>
<a name="1380"><span class="lineNum">    1380 </span>            :         /// &lt;param name=&quot;nc&quot;&gt;How many times it led to an increase in coverage&lt;/param&gt;</a>
<a name="1381"><span class="lineNum">    1381 </span><span class="lineCov">          3 :         seedSimple(std::string input, double T, size_t nm = 1, size_t nc = 1) : seed(std::move(input)), T(T), nm(nm), nc(nc)</span></a>
<a name="1382"><span class="lineNum">    1382 </span>            :         {</a>
<a name="1383"><span class="lineNum">    1383 </span><span class="lineCov">          3 :             e = power();</span></a>
<a name="1384"><span class="lineNum">    1384 </span><span class="lineCov">          3 :         }</span></a>
<a name="1385"><span class="lineNum">    1385 </span>            : </a>
<a name="1386"><span class="lineNum">    1386 </span><span class="lineCov">          4 :         bool operator&lt; (const seedSimple&amp; other) const</span></a>
<a name="1387"><span class="lineNum">    1387 </span>            :         {</a>
<a name="1388"><span class="lineNum">    1388 </span><span class="lineCov">          4 :             return e &gt; other.e;</span></a>
<a name="1389"><span class="lineNum">    1389 </span>            :         }</a>
<a name="1390"><span class="lineNum">    1390 </span>            : </a>
<a name="1391"><span class="lineNum">    1391 </span><span class="lineCov">          4 :         double power() const</span></a>
<a name="1392"><span class="lineNum">    1392 </span>            :         {</a>
<a name="1393"><span class="lineNum">    1393 </span><span class="lineCov">          4 :             return 1.0 / (T * input.size() * nm / nc);</span></a>
<a name="1394"><span class="lineNum">    1394 </span>            :         }</a>
<a name="1395"><span class="lineNum">    1395 </span>            : </a>
<a name="1396"><span class="lineNum">    1396 </span><span class="lineCov">          1 :         virtual void incrementSelected() override final</span></a>
<a name="1397"><span class="lineNum">    1397 </span>            :         {</a>
<a name="1398"><span class="lineNum">    1398 </span><span class="lineCov">          1 :             nm++;</span></a>
<a name="1399"><span class="lineNum">    1399 </span><span class="lineCov">          1 :         }</span></a>
<a name="1400"><span class="lineNum">    1400 </span><span class="lineNoCov">          0 :         virtual void incrementImproved() override final</span></a>
<a name="1401"><span class="lineNum">    1401 </span>            :         {</a>
<a name="1402"><span class="lineNum">    1402 </span><span class="lineNoCov">          0 :             nc++;</span></a>
<a name="1403"><span class="lineNum">    1403 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="1404"><span class="lineNum">    1404 </span><span class="lineCov">          1 :         virtual void update() override final</span></a>
<a name="1405"><span class="lineNum">    1405 </span>            :         {</a>
<a name="1406"><span class="lineNum">    1406 </span><span class="lineCov">          1 :             e = power();</span></a>
<a name="1407"><span class="lineNum">    1407 </span><span class="lineCov">          1 :         }</span></a>
<a name="1408"><span class="lineNum">    1408 </span><span class="lineCov">          3 :         virtual ~seedSimple() = default;</span></a>
<a name="1409"><span class="lineNum">    1409 </span>            :     };</a>
<a name="1410"><span class="lineNum">    1410 </span>            : </a>
<a name="1411"><span class="lineNum">    1411 </span>            :     struct seedBoosted : public seed</a>
<a name="1412"><span class="lineNum">    1412 </span>            :     {</a>
<a name="1413"><span class="lineNum">    1413 </span>            :         const coveragePath&amp; h; //hash of the output</a>
<a name="1414"><span class="lineNum">    1414 </span>            : </a>
<a name="1415"><span class="lineNum">    1415 </span>            :         /// &lt;summary&gt;</a>
<a name="1416"><span class="lineNum">    1416 </span>            :         /// Seed for the boosted power method</a>
<a name="1417"><span class="lineNum">    1417 </span>            :         /// &lt;/summary&gt;</a>
<a name="1418"><span class="lineNum">    1418 </span>            :         /// &lt;param name=&quot;input&quot;&gt;String that should be associated with this seed&lt;/param&gt;</a>
<a name="1419"><span class="lineNum">    1419 </span>            :         /// &lt;param name=&quot;h&quot;&gt;Path that is executed when this seed is run&lt;/param&gt;</a>
<a name="1420"><span class="lineNum">    1420 </span><span class="lineCov">          2 :         seedBoosted(std::string input, const coveragePath&amp; h) : seed(std::move(input)), h(h)</span></a>
<a name="1421"><span class="lineNum">    1421 </span>            :         {</a>
<a name="1422"><span class="lineNum">    1422 </span><span class="lineCov">          2 :         }</span></a>
<a name="1423"><span class="lineNum">    1423 </span>            : </a>
<a name="1424"><span class="lineNum">    1424 </span><span class="lineCov">          3 :         double power(const std::unordered_map&lt;coveragePath, size_t&gt;&amp; hashmap) const</span></a>
<a name="1425"><span class="lineNum">    1425 </span>            :         {</a>
<a name="1426"><span class="lineNum">    1426 </span><span class="lineCov">          3 :             return 1.0 / std::pow(hashmap.at(h), 5);</span></a>
<a name="1427"><span class="lineNum">    1427 </span>            :         }</a>
<a name="1428"><span class="lineNum">    1428 </span>            : </a>
<a name="1429"><span class="lineNum">    1429 </span><span class="lineCov">          1 :         virtual void incrementSelected() override final</span></a>
<a name="1430"><span class="lineNum">    1430 </span>            :         {</a>
<a name="1431"><span class="lineNum">    1431 </span>            :             // Do nothing</a>
<a name="1432"><span class="lineNum">    1432 </span><span class="lineCov">          1 :         }</span></a>
<a name="1433"><span class="lineNum">    1433 </span>            : </a>
<a name="1434"><span class="lineNum">    1434 </span><span class="lineNoCov">          0 :         virtual void incrementImproved() override final</span></a>
<a name="1435"><span class="lineNum">    1435 </span>            :         {</a>
<a name="1436"><span class="lineNum">    1436 </span>            :             // Do nothing</a>
<a name="1437"><span class="lineNum">    1437 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="1438"><span class="lineNum">    1438 </span>            : </a>
<a name="1439"><span class="lineNum">    1439 </span><span class="lineCov">          1 :         virtual void update() override final</span></a>
<a name="1440"><span class="lineNum">    1440 </span>            :         {</a>
<a name="1441"><span class="lineNum">    1441 </span>            :             // Do nothing (will be done when selecting)</a>
<a name="1442"><span class="lineNum">    1442 </span><span class="lineCov">          1 :         }</span></a>
<a name="1443"><span class="lineNum">    1443 </span><span class="lineCov">          3 :         virtual ~seedBoosted() = default;</span></a>
<a name="1444"><span class="lineNum">    1444 </span>            :     };</a>
<a name="1445"><span class="lineNum">    1445 </span>            : </a>
<a name="1446"><span class="lineNum">    1446 </span>            :     struct powerStructure</a>
<a name="1447"><span class="lineNum">    1447 </span>            :     {</a>
<a name="1448"><span class="lineNum">    1448 </span>            :         /// &lt;summary&gt;</a>
<a name="1449"><span class="lineNum">    1449 </span>            :         /// Add new seed into the queue</a>
<a name="1450"><span class="lineNum">    1450 </span>            :         /// &lt;/summary&gt;</a>
<a name="1451"><span class="lineNum">    1451 </span>            :         /// &lt;param name=&quot;input&quot;&gt;String that was fuzzed and should be recorded&lt;/param&gt;</a>
<a name="1452"><span class="lineNum">    1452 </span>            :         /// &lt;param name=&quot;h&quot;&gt;Associated output path from the program&lt;/param&gt;</a>
<a name="1453"><span class="lineNum">    1453 </span>            :         /// &lt;param name=&quot;T&quot;&gt;Runtime for this input&lt;/param&gt;</a>
<a name="1454"><span class="lineNum">    1454 </span>            :         /// &lt;param name=&quot;nm&quot;&gt;How many times it was selected&lt;/param&gt;</a>
<a name="1455"><span class="lineNum">    1455 </span>            :         /// &lt;param name=&quot;nc&quot;&gt;How many times it led to increased coverage&lt;/param&gt;</a>
<a name="1456"><span class="lineNum">    1456 </span>            :         virtual void add(std::string input, const coveragePath&amp; h, double T, size_t nm = 1, size_t nc = 1) = 0;</a>
<a name="1457"><span class="lineNum">    1457 </span>            : </a>
<a name="1458"><span class="lineNum">    1458 </span>            :         /// &lt;summary&gt;</a>
<a name="1459"><span class="lineNum">    1459 </span>            :         /// Size of the queue</a>
<a name="1460"><span class="lineNum">    1460 </span>            :         /// &lt;/summary&gt;</a>
<a name="1461"><span class="lineNum">    1461 </span>            :         virtual size_t size() const = 0;</a>
<a name="1462"><span class="lineNum">    1462 </span>            : </a>
<a name="1463"><span class="lineNum">    1463 </span>            :         /// &lt;summary&gt;</a>
<a name="1464"><span class="lineNum">    1464 </span>            :         /// Retrives seed at given index</a>
<a name="1465"><span class="lineNum">    1465 </span>            :         /// &lt;/summary&gt;</a>
<a name="1466"><span class="lineNum">    1466 </span>            :         /// &lt;param name=&quot;n&quot;&gt;Index&lt;/param&gt;</a>
<a name="1467"><span class="lineNum">    1467 </span>            :         /// &lt;returns&gt;Constant reference to the element&lt;/returns&gt;</a>
<a name="1468"><span class="lineNum">    1468 </span>            :         virtual const seed&amp; at(size_t n) = 0;</a>
<a name="1469"><span class="lineNum">    1469 </span>            : </a>
<a name="1470"><span class="lineNum">    1470 </span>            :         /// &lt;summary&gt;</a>
<a name="1471"><span class="lineNum">    1471 </span>            :         /// Perform a weighted random choice and borrow the seed, expecting to return it</a>
<a name="1472"><span class="lineNum">    1472 </span>            :         /// &lt;/summary&gt;</a>
<a name="1473"><span class="lineNum">    1473 </span>            :         /// &lt;returns&gt;Reference to the selected seed&lt;/returns&gt;</a>
<a name="1474"><span class="lineNum">    1474 </span>            :         virtual seed&amp; weightedRandomChoiceBorrow() = 0;</a>
<a name="1475"><span class="lineNum">    1475 </span>            : </a>
<a name="1476"><span class="lineNum">    1476 </span>            :         /// &lt;summary&gt;</a>
<a name="1477"><span class="lineNum">    1477 </span>            :         /// Return borrowed seed (must be done before borrowing a new one!)</a>
<a name="1478"><span class="lineNum">    1478 </span>            :         /// &lt;/summary&gt;</a>
<a name="1479"><span class="lineNum">    1479 </span>            :         virtual void weightedRandomChoiceReturn() = 0;</a>
<a name="1480"><span class="lineNum">    1480 </span>            : </a>
<a name="1481"><span class="lineNum">    1481 </span><span class="lineCov">          4 :         virtual ~powerStructure() = default;</span></a>
<a name="1482"><span class="lineNum">    1482 </span>            : </a>
<a name="1483"><span class="lineNum">    1483 </span>            :         std::unordered_map&lt;coveragePath, size_t&gt; hashmap;</a>
<a name="1484"><span class="lineNum">    1484 </span>            :     };</a>
<a name="1485"><span class="lineNum">    1485 </span>            : </a>
<a name="1486"><span class="lineNum">    1486 </span>            :     struct powerSimple : public powerStructure</a>
<a name="1487"><span class="lineNum">    1487 </span>            :     {</a>
<a name="1488"><span class="lineNum">    1488 </span>            :         // Currently borrowed seed. Store in in this way to avoid copying.</a>
<a name="1489"><span class="lineNum">    1489 </span>            :         std::pair&lt;std::multiset&lt;seedSimple&gt;::node_type, std::multiset&lt;seedSimple&gt;::const_iterator&gt; borrowed;</a>
<a name="1490"><span class="lineNum">    1490 </span>            : </a>
<a name="1491"><span class="lineNum">    1491 </span>            :     public:</a>
<a name="1492"><span class="lineNum">    1492 </span><span class="lineCov">          3 :         void add(std::string input, double T, size_t nm = 1, size_t nc = 1)</span></a>
<a name="1493"><span class="lineNum">    1493 </span>            :         {</a>
<a name="1494"><span class="lineNum">    1494 </span><span class="lineCov">          3 :             queue.emplace(std::move(input), T, nm, nc);</span></a>
<a name="1495"><span class="lineNum">    1495 </span><span class="lineCov">          3 :         }</span></a>
<a name="1496"><span class="lineNum">    1496 </span><span class="lineCov">          3 :         virtual void add(std::string input, const coveragePath&amp; h, double T, size_t nm = 1, size_t nc = 1) override</span></a>
<a name="1497"><span class="lineNum">    1497 </span>            :         {</a>
<a name="1498"><span class="lineNum">    1498 </span><span class="lineCov">          3 :             add(std::move(input), T, nm, nc);</span></a>
<a name="1499"><span class="lineNum">    1499 </span><span class="lineCov">          3 :         }</span></a>
<a name="1500"><span class="lineNum">    1500 </span><span class="lineCov">          5 :         virtual size_t size() const override</span></a>
<a name="1501"><span class="lineNum">    1501 </span>            :         {</a>
<a name="1502"><span class="lineNum">    1502 </span><span class="lineCov">          5 :             return queue.size();</span></a>
<a name="1503"><span class="lineNum">    1503 </span>            :         }</a>
<a name="1504"><span class="lineNum">    1504 </span><span class="lineCov">          1 :         virtual const seed&amp; at(size_t n) override</span></a>
<a name="1505"><span class="lineNum">    1505 </span>            :         {</a>
<a name="1506"><span class="lineNum">    1506 </span>            :             // Cannot access directly, needs to jump over LL</a>
<a name="1507"><span class="lineNum">    1507 </span><span class="lineCov">          1 :             auto it = queue.cbegin();</span></a>
<a name="1508"><span class="lineNum">    1508 </span><span class="lineCov">          1 :             std::advance(it, n);</span></a>
<a name="1509"><span class="lineNum">    1509 </span><span class="lineCov">          1 :             return *it;</span></a>
<a name="1510"><span class="lineNum">    1510 </span>            :         }</a>
<a name="1511"><span class="lineNum">    1511 </span>            : </a>
<a name="1512"><span class="lineNum">    1512 </span><span class="lineCov">          1 :         virtual seed&amp; weightedRandomChoiceBorrow() override</span></a>
<a name="1513"><span class="lineNum">    1513 </span>            :         {</a>
<a name="1514"><span class="lineNum">    1514 </span><span class="lineCov">          1 :             if (!borrowed.first.empty()) [[unlikely]]</span></a>
<a name="1515"><span class="lineNum">    1515 </span><span class="lineNoCov">          0 :                 throw std::runtime_error(&quot;Attempted to borrow another seed without returning previous one!&quot;);</span></a>
<a name="1516"><span class="lineNum">    1516 </span>            : </a>
<a name="1517"><span class="lineNum">    1517 </span>            :             // Store the random choice in this structure, and give reference to it</a>
<a name="1518"><span class="lineNum">    1518 </span><span class="lineCov">          1 :             borrowed = weightedRandomChoiceExtract();</span></a>
<a name="1519"><span class="lineNum">    1519 </span><span class="lineCov">          1 :             return borrowed.first.value();</span></a>
<a name="1520"><span class="lineNum">    1520 </span>            :         }</a>
<a name="1521"><span class="lineNum">    1521 </span><span class="lineCov">          1 :         virtual void weightedRandomChoiceReturn() override</span></a>
<a name="1522"><span class="lineNum">    1522 </span>            :         {</a>
<a name="1523"><span class="lineNum">    1523 </span><span class="lineCov">          1 :             queue.insert(borrowed.second, std::move(borrowed.first));</span></a>
<a name="1524"><span class="lineNum">    1524 </span><span class="lineCov">          1 :         }</span></a>
<a name="1525"><span class="lineNum">    1525 </span><span class="lineCov">          5 :         virtual ~powerSimple() = default;</span></a>
<a name="1526"><span class="lineNum">    1526 </span>            : </a>
<a name="1527"><span class="lineNum">    1527 </span>            :         /// &lt;summary&gt;</a>
<a name="1528"><span class="lineNum">    1528 </span>            :         /// Weighted random choice of a seed, where some portion of best seeds will be given 50% choice be selected</a>
<a name="1529"><span class="lineNum">    1529 </span>            :         /// &lt;/summary&gt;</a>
<a name="1530"><span class="lineNum">    1530 </span>            :         /// &lt;returns&gt;Selected seed extracted from the queue&lt;/returns&gt;</a>
<a name="1531"><span class="lineNum">    1531 </span><span class="lineCov">          1 :         std::pair&lt;std::multiset&lt;seedSimple&gt;::node_type, std::multiset&lt;seedSimple&gt;::const_iterator&gt; weightedRandomChoiceExtract()</span></a>
<a name="1532"><span class="lineNum">    1532 </span>            :         {</a>
<a name="1533"><span class="lineNum">    1533 </span><span class="lineCov">          1 :             if (queue.empty()) [[unlikely]]</span></a>
<a name="1534"><span class="lineNum">    1534 </span><span class="lineNoCov">          0 :                 throw std::runtime_error(&quot;Queue is empty, cannot choose&quot;);</span></a>
<a name="1535"><span class="lineNum">    1535 </span><span class="lineCov">          1 :             else if (queue.size() == 1)</span></a>
<a name="1536"><span class="lineNum">    1536 </span><span class="lineNoCov">          0 :                 return { queue.extract(queue.cbegin()), std::move(queue.cend()) };</span></a>
<a name="1537"><span class="lineNum">    1537 </span>            : </a>
<a name="1538"><span class="lineNum">    1538 </span><span class="lineCov">          1 :             const size_t firstTenPercent = queue.size() * 0.1f;</span></a>
<a name="1539"><span class="lineNum">    1539 </span><span class="lineCov">          1 :             const double coefficientGood = 0.5 / firstTenPercent;</span></a>
<a name="1540"><span class="lineNum">    1540 </span><span class="lineCov">          1 :             const double coefficientWorse = 0.5 / (queue.size() - firstTenPercent);</span></a>
<a name="1541"><span class="lineNum">    1541 </span>            : </a>
<a name="1542"><span class="lineNum">    1542 </span><span class="lineCov">          1 :             std::uniform_real_distribution&lt;&gt; dis(0.0, 1.0); // Range [0, totalWeight)</span></a>
<a name="1543"><span class="lineNum">    1543 </span>            : </a>
<a name="1544"><span class="lineNum">    1544 </span>            :             // Generate a random number</a>
<a name="1545"><span class="lineNum">    1545 </span><span class="lineCov">          1 :             double randomValue = dis(gen);</span></a>
<a name="1546"><span class="lineNum">    1546 </span>            : </a>
<a name="1547"><span class="lineNum">    1547 </span>            :             // Find the chosen option based on the random value</a>
<a name="1548"><span class="lineNum">    1548 </span><span class="lineCov">          1 :             double cumulativeWeight = 0.0;</span></a>
<a name="1549"><span class="lineNum">    1549 </span>            : </a>
<a name="1550"><span class="lineNum">    1550 </span><span class="lineCov">          1 :             size_t i = 0;</span></a>
<a name="1551"><span class="lineNum">    1551 </span><span class="lineCov">          1 :             for (auto it = queue.cbegin(); it != queue.cend(); it++) {</span></a>
<a name="1552"><span class="lineNum">    1552 </span><span class="lineCov">          1 :                 if (i &lt;= firstTenPercent)</span></a>
<a name="1553"><span class="lineNum">    1553 </span><span class="lineCov">          1 :                     cumulativeWeight += coefficientGood;// Better score</span></a>
<a name="1554"><span class="lineNum">    1554 </span>            :                 else</a>
<a name="1555"><span class="lineNum">    1555 </span><span class="lineNoCov">          0 :                     cumulativeWeight += coefficientWorse;// Worse score</span></a>
<a name="1556"><span class="lineNum">    1556 </span>            : </a>
<a name="1557"><span class="lineNum">    1557 </span><span class="lineCov">          1 :                 if (randomValue &lt;= cumulativeWeight) {</span></a>
<a name="1558"><span class="lineNum">    1558 </span><span class="lineCov">          1 :                     auto nextIt = it++;</span></a>
<a name="1559"><span class="lineNum">    1559 </span><span class="lineCov">          1 :                     return { queue.extract(it), std::move(nextIt) };</span></a>
<a name="1560"><span class="lineNum">    1560 </span>            :                 }</a>
<a name="1561"><span class="lineNum">    1561 </span><span class="lineNoCov">          0 :                 i++;</span></a>
<a name="1562"><span class="lineNum">    1562 </span>            :             }</a>
<a name="1563"><span class="lineNum">    1563 </span>            : </a>
<a name="1564"><span class="lineNum">    1564 </span>            :             // If we get here, there was an issue (e.g., no options, weights not positive)</a>
<a name="1565"><span class="lineNum">    1565 </span><span class="lineNoCov">          0 :             throw std::runtime_error(&quot;Failed to select a weighted random choice.&quot;);</span></a>
<a name="1566"><span class="lineNum">    1566 </span>            :         }</a>
<a name="1567"><span class="lineNum">    1567 </span>            : </a>
<a name="1568"><span class="lineNum">    1568 </span>            :         std::multiset&lt;seedSimple&gt; queue;</a>
<a name="1569"><span class="lineNum">    1569 </span>            :     };</a>
<a name="1570"><span class="lineNum">    1570 </span>            : </a>
<a name="1571"><span class="lineNum">    1571 </span>            :     struct powerBoosted : public powerStructure</a>
<a name="1572"><span class="lineNum">    1572 </span>            :     {</a>
<a name="1573"><span class="lineNum">    1573 </span>            :         bool isBorrowed = false;</a>
<a name="1574"><span class="lineNum">    1574 </span>            : </a>
<a name="1575"><span class="lineNum">    1575 </span><span class="lineCov">          2 :         void add(std::string input, const coveragePath&amp; h)</span></a>
<a name="1576"><span class="lineNum">    1576 </span>            :         {</a>
<a name="1577"><span class="lineNum">    1577 </span><span class="lineCov">          2 :             if(isBorrowed) [[unlikely]]</span></a>
<a name="1578"><span class="lineNum">    1578 </span><span class="lineNoCov">          0 :                 throw std::logic_error(&quot;Cannot add to queue with borrowed element&quot;); // Else it could cause reallocation of vector memory and this damned bug would be so difficult to find that you would spend your whole day finding it and not doing anythine else ask me how I know</span></a>
<a name="1579"><span class="lineNum">    1579 </span><span class="lineCov">          2 :             queue.emplace_back(std::move(input), h);</span></a>
<a name="1580"><span class="lineNum">    1580 </span><span class="lineCov">          2 :         }</span></a>
<a name="1581"><span class="lineNum">    1581 </span><span class="lineCov">          2 :         virtual void add(std::string input, const coveragePath&amp; h, double T, size_t nm = 1, size_t nc = 1) override</span></a>
<a name="1582"><span class="lineNum">    1582 </span>            :         {</a>
<a name="1583"><span class="lineNum">    1583 </span><span class="lineCov">          2 :             add(std::move(input), h);</span></a>
<a name="1584"><span class="lineNum">    1584 </span><span class="lineCov">          2 :         }</span></a>
<a name="1585"><span class="lineNum">    1585 </span><span class="lineCov">          2 :         virtual size_t size() const override</span></a>
<a name="1586"><span class="lineNum">    1586 </span>            :         {</a>
<a name="1587"><span class="lineNum">    1587 </span><span class="lineCov">          2 :             return queue.size();</span></a>
<a name="1588"><span class="lineNum">    1588 </span>            :         }</a>
<a name="1589"><span class="lineNum">    1589 </span>            : </a>
<a name="1590"><span class="lineNum">    1590 </span><span class="lineCov">          1 :         virtual const seed&amp; at(size_t n) override</span></a>
<a name="1591"><span class="lineNum">    1591 </span>            :         {</a>
<a name="1592"><span class="lineNum">    1592 </span><span class="lineCov">          1 :             return queue.at(n);</span></a>
<a name="1593"><span class="lineNum">    1593 </span>            :         }</a>
<a name="1594"><span class="lineNum">    1594 </span>            : </a>
<a name="1595"><span class="lineNum">    1595 </span><span class="lineCov">          1 :         virtual seed&amp; weightedRandomChoiceBorrow() override</span></a>
<a name="1596"><span class="lineNum">    1596 </span>            :         {</a>
<a name="1597"><span class="lineNum">    1597 </span><span class="lineCov">          1 :             isBorrowed = true;</span></a>
<a name="1598"><span class="lineNum">    1598 </span><span class="lineCov">          1 :             return weightedRandomChoice();</span></a>
<a name="1599"><span class="lineNum">    1599 </span>            :         }</a>
<a name="1600"><span class="lineNum">    1600 </span>            : </a>
<a name="1601"><span class="lineNum">    1601 </span><span class="lineCov">          1 :         virtual void weightedRandomChoiceReturn() override</span></a>
<a name="1602"><span class="lineNum">    1602 </span>            :         {</a>
<a name="1603"><span class="lineNum">    1603 </span><span class="lineCov">          1 :             isBorrowed = false;</span></a>
<a name="1604"><span class="lineNum">    1604 </span><span class="lineCov">          1 :         }</span></a>
<a name="1605"><span class="lineNum">    1605 </span><span class="lineCov">          1 :         virtual ~powerBoosted() = default;</span></a>
<a name="1606"><span class="lineNum">    1606 </span>            : </a>
<a name="1607"><span class="lineNum">    1607 </span>            :         /// &lt;summary&gt;</a>
<a name="1608"><span class="lineNum">    1608 </span>            :         /// Weighted random choice of a seed</a>
<a name="1609"><span class="lineNum">    1609 </span>            :         /// &lt;/summary&gt;</a>
<a name="1610"><span class="lineNum">    1610 </span>            :         /// &lt;returns&gt;Reference to the selected seed&lt;/returns&gt;</a>
<a name="1611"><span class="lineNum">    1611 </span><span class="lineCov">          1 :         virtual seed&amp; weightedRandomChoice()</span></a>
<a name="1612"><span class="lineNum">    1612 </span>            :         {</a>
<a name="1613"><span class="lineNum">    1613 </span><span class="lineCov">          1 :             if (queue.empty()) [[unlikely]]</span></a>
<a name="1614"><span class="lineNum">    1614 </span><span class="lineNoCov">          0 :                 throw std::runtime_error(&quot;Queue is empty, cannot choose&quot;);</span></a>
<a name="1615"><span class="lineNum">    1615 </span>            : </a>
<a name="1616"><span class="lineNum">    1616 </span>            :             // Calculate the total weight</a>
<a name="1617"><span class="lineNum">    1617 </span><span class="lineCov">          1 :             double totalWeight = 0.0;</span></a>
<a name="1618"><span class="lineNum">    1618 </span><span class="lineCov">          3 :             for (const auto&amp; option : queue)</span></a>
<a name="1619"><span class="lineNum">    1619 </span><span class="lineCov">          2 :                 totalWeight += option.power(hashmap);</span></a>
<a name="1620"><span class="lineNum">    1620 </span>            : </a>
<a name="1621"><span class="lineNum">    1621 </span><span class="lineCov">          1 :             std::uniform_real_distribution&lt;&gt; dis(0.0, totalWeight); // Range [0, totalWeight)</span></a>
<a name="1622"><span class="lineNum">    1622 </span>            : </a>
<a name="1623"><span class="lineNum">    1623 </span>            :             // Generate a random number</a>
<a name="1624"><span class="lineNum">    1624 </span><span class="lineCov">          1 :             double randomValue = dis(gen);</span></a>
<a name="1625"><span class="lineNum">    1625 </span>            : </a>
<a name="1626"><span class="lineNum">    1626 </span>            :             // Find the chosen option based on the random value</a>
<a name="1627"><span class="lineNum">    1627 </span><span class="lineCov">          1 :             double cumulativeWeight = 0.0;</span></a>
<a name="1628"><span class="lineNum">    1628 </span>            : </a>
<a name="1629"><span class="lineNum">    1629 </span><span class="lineCov">          1 :             for (auto&amp; i : queue)</span></a>
<a name="1630"><span class="lineNum">    1630 </span>            :             {</a>
<a name="1631"><span class="lineNum">    1631 </span><span class="lineCov">          1 :                 cumulativeWeight += i.power(hashmap);</span></a>
<a name="1632"><span class="lineNum">    1632 </span><span class="lineCov">          1 :                 if (randomValue &lt;= cumulativeWeight)</span></a>
<a name="1633"><span class="lineNum">    1633 </span><span class="lineCov">          1 :                     return i;</span></a>
<a name="1634"><span class="lineNum">    1634 </span>            :             }</a>
<a name="1635"><span class="lineNum">    1635 </span>            : </a>
<a name="1636"><span class="lineNum">    1636 </span>            :             // If we get here, there was an issue (e.g., no options, weights not positive)</a>
<a name="1637"><span class="lineNum">    1637 </span><span class="lineNoCov">          0 :             throw std::runtime_error(&quot;Failed to select a weighted random choice.&quot;);</span></a>
<a name="1638"><span class="lineNum">    1638 </span>            :         }</a>
<a name="1639"><span class="lineNum">    1639 </span>            : </a>
<a name="1640"><span class="lineNum">    1640 </span>            :         std::vector&lt;seedBoosted&gt; queue;</a>
<a name="1641"><span class="lineNum">    1641 </span>            :     };</a>
<a name="1642"><span class="lineNum">    1642 </span>            : </a>
<a name="1643"><span class="lineNum">    1643 </span>            :     /// &lt;summary&gt;</a>
<a name="1644"><span class="lineNum">    1644 </span>            :     /// Joins random number of seeds together, possible with delimiters</a>
<a name="1645"><span class="lineNum">    1645 </span>            :     /// &lt;/summary&gt;</a>
<a name="1646"><span class="lineNum">    1646 </span>            :     /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;</a>
<a name="1647"><span class="lineNum">    1647 </span><span class="lineNoCov">          0 :     void createMashups(std::string&amp; input)</span></a>
<a name="1648"><span class="lineNum">    1648 </span>            :     {</a>
<a name="1649"><span class="lineNum">    1649 </span><span class="lineNoCov">          0 :         std::exponential_distribution&lt;float&gt; distVal(0.5);</span></a>
<a name="1650"><span class="lineNum">    1650 </span><span class="lineNoCov">          0 :         size_t mashups = 1 + round(distVal(gen));</span></a>
<a name="1651"><span class="lineNum">    1651 </span><span class="lineNoCov">          0 :         for (size_t i = 0; i &lt; mashups; i++)</span></a>
<a name="1652"><span class="lineNum">    1652 </span>            :         {</a>
<a name="1653"><span class="lineNum">    1653 </span><span class="lineNoCov">          0 :             switch (generators::randomInt(6))</span></a>
<a name="1654"><span class="lineNum">    1654 </span>            :             {</a>
<a name="1655"><span class="lineNum">    1655 </span><span class="lineNoCov">          0 :             case 0:</span></a>
<a name="1656"><span class="lineNum">    1656 </span><span class="lineNoCov">          0 :                 input += '\n';</span></a>
<a name="1657"><span class="lineNum">    1657 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="1658"><span class="lineNum">    1658 </span><span class="lineNoCov">          0 :             case 1:</span></a>
<a name="1659"><span class="lineNum">    1659 </span><span class="lineNoCov">          0 :                 input += generators::randomDigit();</span></a>
<a name="1660"><span class="lineNum">    1660 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="1661"><span class="lineNum">    1661 </span><span class="lineNoCov">          0 :             case 2:</span></a>
<a name="1662"><span class="lineNum">    1662 </span><span class="lineNoCov">          0 :                 input += generators::randomASCII();</span></a>
<a name="1663"><span class="lineNum">    1663 </span><span class="lineNoCov">          0 :                 break;</span></a>
<a name="1664"><span class="lineNum">    1664 </span><span class="lineNoCov">          0 :             case 3:</span></a>
<a name="1665"><span class="lineNum">    1665 </span>            :             case 4:</a>
<a name="1666"><span class="lineNum">    1666 </span>            :             case 5:</a>
<a name="1667"><span class="lineNum">    1667 </span>            :             {</a>
<a name="1668"><span class="lineNum">    1668 </span><span class="lineNoCov">          0 :                 input += queue-&gt;at(generators::randomInt(queue-&gt;size())).input;</span></a>
<a name="1669"><span class="lineNum">    1669 </span><span class="lineNoCov">          0 :             } break;</span></a>
<a name="1670"><span class="lineNum">    1670 </span>            : </a>
<a name="1671"><span class="lineNum">    1671 </span><span class="lineNoCov">          0 :             default:</span></a>
<a name="1672"><span class="lineNum">    1672 </span><span class="lineNoCov">          0 :                 UNREACHABLE;</span></a>
<a name="1673"><span class="lineNum">    1673 </span>            :             }</a>
<a name="1674"><span class="lineNum">    1674 </span>            :         }</a>
<a name="1675"><span class="lineNum">    1675 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1676"><span class="lineNum">    1676 </span>            : </a>
<a name="1677"><span class="lineNum">    1677 </span>            :     /// &lt;summary&gt;</a>
<a name="1678"><span class="lineNum">    1678 </span>            :     /// Perform generation of a new mutant. Given the chance from the constructor, also splice/join multiple existing seeds together.</a>
<a name="1679"><span class="lineNum">    1679 </span>            :     /// &lt;/summary&gt;</a>
<a name="1680"><span class="lineNum">    1680 </span>            :     /// &lt;param name=&quot;input&quot;&gt;&lt;/param&gt;</a>
<a name="1681"><span class="lineNum">    1681 </span>            :     /// &lt;returns&gt;&lt;/returns&gt;</a>
<a name="1682"><span class="lineNum">    1682 </span><span class="lineNoCov">          0 :     std::string randomNumberOfRandomMutants(std::string input)</span></a>
<a name="1683"><span class="lineNum">    1683 </span>            :     {</a>
<a name="1684"><span class="lineNum">    1684 </span><span class="lineNoCov">          0 :         if (generators::randomFloat() &lt; concatenatedness)</span></a>
<a name="1685"><span class="lineNum">    1685 </span><span class="lineNoCov">          0 :             createMashups(input); // Perform joining</span></a>
<a name="1686"><span class="lineNum">    1686 </span>            :         else</a>
<a name="1687"><span class="lineNum">    1687 </span><span class="lineNoCov">          0 :             mutators::randomNumberOfRandomMutants(input); // Perform mutation</span></a>
<a name="1688"><span class="lineNum">    1688 </span>            : </a>
<a name="1689"><span class="lineNum">    1689 </span><span class="lineNoCov">          0 :         return input;</span></a>
<a name="1690"><span class="lineNum">    1690 </span>            :     }</a>
<a name="1691"><span class="lineNum">    1691 </span>            : </a>
<a name="1692"><span class="lineNum">    1692 </span><span class="lineCov">          2 :     virtual void exportStatistics(std::ostream&amp; out) override</span></a>
<a name="1693"><span class="lineNum">    1693 </span>            :     {</a>
<a name="1694"><span class="lineNum">    1694 </span><span class="lineCov">          2 :         out &lt;&lt; '{';</span></a>
<a name="1695"><span class="lineNum">    1695 </span><span class="lineCov">          2 :         exportStatisticsCommon(out);</span></a>
<a name="1696"><span class="lineNum">    1696 </span><span class="lineCov">          2 :         out &lt;&lt; &quot;,\&quot;nb_queued_seed\&quot;:&quot; &lt;&lt; queue-&gt;size() &lt;&lt; &quot;,&quot;;</span></a>
<a name="1697"><span class="lineNum">    1697 </span><span class="lineCov">          2 :         out &lt;&lt; &quot;\&quot;coverage\&quot;:&quot; &lt;&lt; bestCoverage * 100 &lt;&lt; &quot;,&quot;;</span></a>
<a name="1698"><span class="lineNum">    1698 </span><span class="lineCov">          2 :         out &lt;&lt; &quot;\&quot;nb_unique_hash\&quot;:&quot; &lt;&lt; queue-&gt;hashmap.size();</span></a>
<a name="1699"><span class="lineNum">    1699 </span><span class="lineCov">          2 :         out &lt;&lt; '}';</span></a>
<a name="1700"><span class="lineNum">    1700 </span><span class="lineCov">          2 :     }</span></a>
<a name="1701"><span class="lineNum">    1701 </span><span class="lineCov">          2 :     virtual void exportReport(const CrashReport&amp; report, std::ostream&amp; out) const override</span></a>
<a name="1702"><span class="lineNum">    1702 </span>            :     {</a>
<a name="1703"><span class="lineNum">    1703 </span><span class="lineCov">          2 :         out &lt;&lt; '{';</span></a>
<a name="1704"><span class="lineNum">    1704 </span><span class="lineCov">          2 :         exportReportCommon(report, out);</span></a>
<a name="1705"><span class="lineNum">    1705 </span><span class="lineCov">          2 :         out &lt;&lt; &quot;,\&quot;coverage\&quot;:&quot; &lt;&lt; bestCoverage * 100;</span></a>
<a name="1706"><span class="lineNum">    1706 </span><span class="lineCov">          2 :         out &lt;&lt; '}';</span></a>
<a name="1707"><span class="lineNum">    1707 </span><span class="lineCov">          2 :     }</span></a>
<a name="1708"><span class="lineNum">    1708 </span>            : </a>
<a name="1709"><span class="lineNum">    1709 </span>            :     /// &lt;summary&gt;</a>
<a name="1710"><span class="lineNum">    1710 </span>            :     /// Get line from the input, split by the delimiter</a>
<a name="1711"><span class="lineNum">    1711 </span>            :     /// &lt;/summary&gt;</a>
<a name="1712"><span class="lineNum">    1712 </span>            :     /// &lt;param name=&quot;str&quot;&gt;String to read from. Will be eaten&lt;/param&gt;</a>
<a name="1713"><span class="lineNum">    1713 </span>            :     /// &lt;param name=&quot;delimiter&quot;&gt;Delimiter to read line to. Will be removed from input&lt;/param&gt;</a>
<a name="1714"><span class="lineNum">    1714 </span>            :     /// &lt;returns&gt;Read line, without delimiter&lt;/returns&gt;</a>
<a name="1715"><span class="lineNum">    1715 </span><span class="lineCov">         19 :     static std::string_view getLine(std::string_view&amp; str, char delimiter='\n')</span></a>
<a name="1716"><span class="lineNum">    1716 </span>            :     {</a>
<a name="1717"><span class="lineNum">    1717 </span><span class="lineCov">         19 :         size_t i = 0;</span></a>
<a name="1718"><span class="lineNum">    1718 </span><span class="lineCov">         98 :         for (; i &lt; str.size(); ++i)</span></a>
<a name="1719"><span class="lineNum">    1719 </span>            :         {</a>
<a name="1720"><span class="lineNum">    1720 </span><span class="lineCov">         98 :             if (str[i] == delimiter)</span></a>
<a name="1721"><span class="lineNum">    1721 </span><span class="lineCov">         19 :                 break;</span></a>
<a name="1722"><span class="lineNum">    1722 </span>            :         }</a>
<a name="1723"><span class="lineNum">    1723 </span><span class="lineCov">         19 :         auto res = str.substr(0, i);</span></a>
<a name="1724"><span class="lineNum">    1724 </span><span class="lineCov">         19 :         if (i &gt;= str.size())</span></a>
<a name="1725"><span class="lineNum">    1725 </span><span class="lineNoCov">          0 :             str = &quot;&quot;;</span></a>
<a name="1726"><span class="lineNum">    1726 </span>            :         else</a>
<a name="1727"><span class="lineNum">    1727 </span><span class="lineCov">         19 :             str = str.substr(i + 1);</span></a>
<a name="1728"><span class="lineNum">    1728 </span><span class="lineCov">         19 :         return res;</span></a>
<a name="1729"><span class="lineNum">    1729 </span>            :     }</a>
<a name="1730"><span class="lineNum">    1730 </span>            : </a>
<a name="1731"><span class="lineNum">    1731 </span>            :     /// &lt;summary&gt;</a>
<a name="1732"><span class="lineNum">    1732 </span>            :     /// Reads coverage percentage from a input</a>
<a name="1733"><span class="lineNum">    1733 </span>            :     /// &lt;/summary&gt;</a>
<a name="1734"><span class="lineNum">    1734 </span><span class="lineCov">          1 :     static std::pair&lt;double, coveragePath&gt; coverage(const std::string&amp; lcov)</span></a>
<a name="1735"><span class="lineNum">    1735 </span>            :     {</a>
<a name="1736"><span class="lineNum">    1736 </span><span class="lineCov">          1 :         std::pair&lt;double, coveragePath&gt; res;</span></a>
<a name="1737"><span class="lineNum">    1737 </span><span class="lineCov">          1 :         std::string_view str(lcov);</span></a>
<a name="1738"><span class="lineNum">    1738 </span><span class="lineCov">          1 :         size_t covered = 0;</span></a>
<a name="1739"><span class="lineNum">    1739 </span>            : </a>
<a name="1740"><span class="lineNum">    1740 </span>            :         //Read lines until name of the file is present. (This is probably just for our coverage tool)</a>
<a name="1741"><span class="lineNum">    1741 </span>            :         while (true)</a>
<a name="1742"><span class="lineNum">    1742 </span>            :         {</a>
<a name="1743"><span class="lineNum">    1743 </span><span class="lineCov">          5 :             while (!getLine(str).starts_with(&quot;SF:&quot;))</span></a>
<a name="1744"><span class="lineNum">    1744 </span>            :             {</a>
<a name="1745"><span class="lineNum">    1745 </span><span class="lineCov">          4 :                 if (str.empty())</span></a>
<a name="1746"><span class="lineNum">    1746 </span><span class="lineCov">          1 :                     goto foundEverything;</span></a>
<a name="1747"><span class="lineNum">    1747 </span>            :             }</a>
<a name="1748"><span class="lineNum">    1748 </span>            : </a>
<a name="1749"><span class="lineNum">    1749 </span><span class="lineCov">          8 :             while (str.starts_with(&quot;DA:&quot;))</span></a>
<a name="1750"><span class="lineNum">    1750 </span>            :             {</a>
<a name="1751"><span class="lineNum">    1751 </span><span class="lineCov">          7 :                 getLine(str, ','); // Eat up to the comma</span></a>
<a name="1752"><span class="lineNum">    1752 </span><span class="lineCov">          7 :                 std::string_view numStr = getLine(str, '\n'); // Get the number</span></a>
<a name="1753"><span class="lineNum">    1753 </span>            :                 size_t countHit;</a>
<a name="1754"><span class="lineNum">    1754 </span><span class="lineCov">          7 :                 std::from_chars(numStr.data(), numStr.data() + numStr.size(), countHit); // Parse number</span></a>
<a name="1755"><span class="lineNum">    1755 </span><span class="lineCov">          7 :                 res.second.push_back(countHit &gt; 0);</span></a>
<a name="1756"><span class="lineNum">    1756 </span><span class="lineCov">          7 :                 if (countHit &gt; 0)</span></a>
<a name="1757"><span class="lineNum">    1757 </span><span class="lineCov">          6 :                     covered++;</span></a>
<a name="1758"><span class="lineNum">    1758 </span>            :             }</a>
<a name="1759"><span class="lineNum">    1759 </span><span class="lineCov">          1 :         }</span></a>
<a name="1760"><span class="lineNum">    1760 </span><span class="lineCov">          1 :         foundEverything:</span></a>
<a name="1761"><span class="lineNum">    1761 </span>            : </a>
<a name="1762"><span class="lineNum">    1762 </span><span class="lineCov">          1 :         size_t total = res.second.size();</span></a>
<a name="1763"><span class="lineNum">    1763 </span>            : </a>
<a name="1764"><span class="lineNum">    1764 </span><span class="lineCov">          1 :         res.first = static_cast&lt;double&gt;(covered) / total;</span></a>
<a name="1765"><span class="lineNum">    1765 </span>            : </a>
<a name="1766"><span class="lineNum">    1766 </span><span class="lineCov">          2 :         return res;</span></a>
<a name="1767"><span class="lineNum">    1767 </span><span class="lineNoCov">          0 :     }</span></a>
<a name="1768"><span class="lineNum">    1768 </span>            : </a>
<a name="1769"><span class="lineNum">    1769 </span>            :     /// &lt;summary&gt;</a>
<a name="1770"><span class="lineNum">    1770 </span>            :     /// Try to run a seed, and reward it if it succeeds</a>
<a name="1771"><span class="lineNum">    1771 </span>            :     /// &lt;/summary&gt;</a>
<a name="1772"><span class="lineNum">    1772 </span>            :     /// &lt;param name=&quot;parent&quot;&gt;Seed that the mutant was taken from, nullptr if orphan (initial seed)&lt;/param&gt;</a>
<a name="1773"><span class="lineNum">    1773 </span>            :     /// &lt;param name=&quot;mutant&quot;&gt;Mutant to run on&lt;/param&gt;</a>
<a name="1774"><span class="lineNum">    1774 </span>            :     /// &lt;typeparam name=&quot;alwaysInsert&quot;&gt;Always insert in the queue, even if no improvement occurs&lt;/param&gt;</a>
<a name="1775"><span class="lineNum">    1775 </span>            :     template &lt;bool alwaysInsert = false&gt;</a>
<a name="1776"><span class="lineNum">    1776 </span><span class="lineCov">          1 :     void trySeed(seed * parent, std::string mutant)</span></a>
<a name="1777"><span class="lineNum">    1777 </span>            :     {</a>
<a name="1778"><span class="lineNum">    1778 </span>            :         // Prepare input for execution</a>
<a name="1779"><span class="lineNum">    1779 </span><span class="lineCov">          1 :         executionInput-&gt;setInput(mutant);</span></a>
<a name="1780"><span class="lineNum">    1780 </span>            : </a>
<a name="1781"><span class="lineNum">    1781 </span>            :         // Execute the actual program</a>
<a name="1782"><span class="lineNum">    1782 </span><span class="lineCov">          1 :         auto res = execute_with_timeout(*executionInput);</span></a>
<a name="1783"><span class="lineNum">    1783 </span>            : </a>
<a name="1784"><span class="lineNum">    1784 </span>            :         // Check whether error occured, record it and minimize</a>
<a name="1785"><span class="lineNum">    1785 </span><span class="lineCov">          1 :         auto error = dealWithResult(mutant, res, *executionInput, false);</span></a>
<a name="1786"><span class="lineNum">    1786 </span>            : </a>
<a name="1787"><span class="lineNum">    1787 </span>            :         // Load coverage from file</a>
<a name="1788"><span class="lineNum">    1788 </span><span class="lineCov">          1 :         double executedCoveragePercent = 0;</span></a>
<a name="1789"><span class="lineNum">    1789 </span><span class="lineCov">          1 :         coveragePath executedCoveragePath;</span></a>
<a name="1790"><span class="lineNum">    1790 </span><span class="lineCov">          1 :         if (std::filesystem::exists(COVERAGE_FILE)) //Sometimes no coverage file is available (error etc.)</span></a>
<a name="1791"><span class="lineNum">    1791 </span>            :         {</a>
<a name="1792"><span class="lineNum">    1792 </span><span class="lineNoCov">          0 :             auto lcov = loadFile(COVERAGE_FILE);</span></a>
<a name="1793"><span class="lineNum">    1793 </span><span class="lineNoCov">          0 :             std::filesystem::remove(COVERAGE_FILE);</span></a>
<a name="1794"><span class="lineNum">    1794 </span>            : </a>
<a name="1795"><span class="lineNum">    1795 </span><span class="lineNoCov">          0 :             auto tmp = coverage(lcov);</span></a>
<a name="1796"><span class="lineNum">    1796 </span>            : </a>
<a name="1797"><span class="lineNum">    1797 </span><span class="lineNoCov">          0 :             executedCoveragePercent = std::move(tmp.first);</span></a>
<a name="1798"><span class="lineNum">    1798 </span><span class="lineNoCov">          0 :             executedCoveragePath = std::move(tmp.second);</span></a>
<a name="1799"><span class="lineNum">    1799 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="1800"><span class="lineNum">    1800 </span>            :         // else use empty path (for errors)</a>
<a name="1801"><span class="lineNum">    1801 </span>            : </a>
<a name="1802"><span class="lineNum">    1802 </span>            :         // Insert it into hashtable</a>
<a name="1803"><span class="lineNum">    1803 </span><span class="lineCov">          1 :         auto it = queue-&gt;hashmap.emplace(std::move(executedCoveragePath), 0);</span></a>
<a name="1804"><span class="lineNum">    1804 </span><span class="lineCov">          1 :         it.first-&gt;second++;;</span></a>
<a name="1805"><span class="lineNum">    1805 </span><span class="lineCov">          1 :         const auto&amp; recordedCoveragePath = it.first-&gt;first;</span></a>
<a name="1806"><span class="lineNum">    1806 </span><span class="lineCov">          1 :         bool foundNewPath = it.second; // If this created a new element in the table</span></a>
<a name="1807"><span class="lineNum">    1807 </span>            : </a>
<a name="1808"><span class="lineNum">    1808 </span>            :         // If this mutant has a parent</a>
<a name="1809"><span class="lineNum">    1809 </span><span class="lineCov">          1 :         if (parent != nullptr)</span></a>
<a name="1810"><span class="lineNum">    1810 </span>            :         {</a>
<a name="1811"><span class="lineNum">    1811 </span>            :             // Reward parent for finding a new path</a>
<a name="1812"><span class="lineNum">    1812 </span><span class="lineNoCov">          0 :             if (foundNewPath)</span></a>
<a name="1813"><span class="lineNum">    1813 </span><span class="lineNoCov">          0 :                 parent-&gt;incrementImproved();</span></a>
<a name="1814"><span class="lineNum">    1814 </span>            : </a>
<a name="1815"><span class="lineNum">    1815 </span>            :             // Update and return the original seed back to the queue</a>
<a name="1816"><span class="lineNum">    1816 </span><span class="lineNoCov">          0 :             parent-&gt;update();</span></a>
<a name="1817"><span class="lineNum">    1817 </span><span class="lineNoCov">          0 :             queue-&gt;weightedRandomChoiceReturn();</span></a>
<a name="1818"><span class="lineNum">    1818 </span>            :         }</a>
<a name="1819"><span class="lineNum">    1819 </span>            : </a>
<a name="1820"><span class="lineNum">    1820 </span>            :         // Add new interesting seed (crashing)</a>
<a name="1821"><span class="lineNum">    1821 </span><span class="lineNoCov">          0 :         if (alwaysInsert || foundNewPath)</span></a>
<a name="1822"><span class="lineNum">    1822 </span><span class="lineCov">          1 :             queue-&gt;add(std::move(mutant), recordedCoveragePath, res.execution_time.count(), 1, 1);</span></a>
<a name="1823"><span class="lineNum">    1823 </span>            : </a>
<a name="1824"><span class="lineNum">    1824 </span>            :         // Improve coverage score (if it wasn't error)</a>
<a name="1825"><span class="lineNum">    1825 </span><span class="lineCov">          1 :         if (!error &amp;&amp; executedCoveragePercent &gt; bestCoverage)</span></a>
<a name="1826"><span class="lineNum">    1826 </span>            :         {</a>
<a name="1827"><span class="lineNum">    1827 </span><span class="lineNoCov">          0 :             std::cerr &lt;&lt; &quot;Just improved coverage! From &quot; &lt;&lt; bestCoverage &lt;&lt; &quot; to &quot; &lt;&lt; executedCoveragePercent &lt;&lt; &quot;. nb_runs=&quot; &lt;&lt; statisticsExecution.count() &lt;&lt; std::endl;</span></a>
<a name="1828"><span class="lineNum">    1828 </span><span class="lineNoCov">          0 :             bestCoverage = executedCoveragePercent;</span></a>
<a name="1829"><span class="lineNum">    1829 </span>            :         }</a>
<a name="1830"><span class="lineNum">    1830 </span><span class="lineCov">          1 :     }</span></a>
<a name="1831"><span class="lineNum">    1831 </span>            : </a>
<a name="1832"><span class="lineNum">    1832 </span>            :     std::unique_ptr&lt;powerStructure&gt; queue;</a>
<a name="1833"><span class="lineNum">    1833 </span>            :     double bestCoverage = 0;</a>
<a name="1834"><span class="lineNum">    1834 </span>            : </a>
<a name="1835"><span class="lineNum">    1835 </span><span class="lineCov">          1 :     virtual void fuzz() override</span></a>
<a name="1836"><span class="lineNum">    1836 </span>            :     {</a>
<a name="1837"><span class="lineNum">    1837 </span>            :         // Run for initial seeds without mutating</a>
<a name="1838"><span class="lineNum">    1838 </span><span class="lineCov">          1 :         std::cerr &lt;&lt; &quot;Executing on empty input to set a coverage&quot; &lt;&lt; std::endl;</span></a>
<a name="1839"><span class="lineNum">    1839 </span><span class="lineCov">          1 :         executionInput-&gt;setInput(&quot;&quot;);</span></a>
<a name="1840"><span class="lineNum">    1840 </span><span class="lineCov">          1 :         execute_with_timeout(*executionInput);</span></a>
<a name="1841"><span class="lineNum">    1841 </span><span class="lineCov">          1 :         if (std::filesystem::exists(COVERAGE_FILE))</span></a>
<a name="1842"><span class="lineNum">    1842 </span>            :         {</a>
<a name="1843"><span class="lineNum">    1843 </span><span class="lineNoCov">          0 :             auto lcov = loadFile(COVERAGE_FILE);</span></a>
<a name="1844"><span class="lineNum">    1844 </span><span class="lineNoCov">          0 :             std::filesystem::remove(COVERAGE_FILE);</span></a>
<a name="1845"><span class="lineNum">    1845 </span><span class="lineNoCov">          0 :             bestCoverage = coverage(lcov).first;</span></a>
<a name="1846"><span class="lineNum">    1846 </span><span class="lineNoCov">          0 :         }</span></a>
<a name="1847"><span class="lineNum">    1847 </span><span class="lineCov">          1 :         std::cerr &lt;&lt; &quot;Initial coverage set to &quot; &lt;&lt; bestCoverage &lt;&lt; std::endl;</span></a>
<a name="1848"><span class="lineNum">    1848 </span>            : </a>
<a name="1849"><span class="lineNum">    1849 </span><span class="lineCov">          1 :         std::cerr &lt;&lt; &quot;Executing initial seeds...&quot; &lt;&lt; std::endl;</span></a>
<a name="1850"><span class="lineNum">    1850 </span><span class="lineCov">          4 :         for (const auto&amp; i : std::filesystem::directory_iterator(INPUT_SEEDS))</span></a>
<a name="1851"><span class="lineNum">    1851 </span>            :         {</a>
<a name="1852"><span class="lineNum">    1852 </span><span class="lineCov">          2 :             if (!keepRunning)</span></a>
<a name="1853"><span class="lineNum">    1853 </span><span class="lineCov">          1 :                 break;</span></a>
<a name="1854"><span class="lineNum">    1854 </span><span class="lineCov">          1 :             if (i.is_regular_file())</span></a>
<a name="1855"><span class="lineNum">    1855 </span>            :             {</a>
<a name="1856"><span class="lineNum">    1856 </span>            :                 // Run directly on this seed</a>
<a name="1857"><span class="lineNum">    1857 </span><span class="lineCov">          1 :                 auto input = loadFile(i.path());</span></a>
<a name="1858"><span class="lineNum">    1858 </span>            : </a>
<a name="1859"><span class="lineNum">    1859 </span>            :                 // Check if input does not contain control characters (we don't support those)</a>
<a name="1860"><span class="lineNum">    1860 </span><span class="lineCov">          7 :                 for (const auto&amp; c : input)</span></a>
<a name="1861"><span class="lineNum">    1861 </span><span class="lineCov">          6 :                     if (!isJsonAllowedOrEscapeable(c))</span></a>
<a name="1862"><span class="lineNum">    1862 </span><span class="lineNoCov">          0 :                         goto containsEscapes;</span></a>
<a name="1863"><span class="lineNum">    1863 </span>            : </a>
<a name="1864"><span class="lineNum">    1864 </span><span class="lineCov">          1 :                 trySeed&lt;true&gt;(nullptr, std::move(input));</span></a>
<a name="1865"><span class="lineNum">    1865 </span>            : </a>
<a name="1866"><span class="lineNum">    1866 </span><span class="lineCov">          1 :             containsEscapes:</span></a>
<a name="1867"><span class="lineNum">    1867 </span><span class="lineCov">          1 :                 while (0);</span></a>
<a name="1868"><span class="lineNum">    1868 </span><span class="lineCov">          1 :             }</span></a>
<a name="1869"><span class="lineNum">    1869 </span><span class="lineCov">          1 :         }</span></a>
<a name="1870"><span class="lineNum">    1870 </span><span class="lineCov">          1 :         std::cerr &lt;&lt; &quot;Loaded &quot; &lt;&lt; queue-&gt;size() &lt;&lt; &quot; seeds.&quot; &lt;&lt; std::endl;</span></a>
<a name="1871"><span class="lineNum">    1871 </span>            : </a>
<a name="1872"><span class="lineNum">    1872 </span><span class="lineCov">          1 :         std::cerr &lt;&lt; &quot;Mutating...&quot; &lt;&lt; std::endl;</span></a>
<a name="1873"><span class="lineNum">    1873 </span><span class="lineCov">          1 :         while (keepRunning)</span></a>
<a name="1874"><span class="lineNum">    1874 </span>            :         {</a>
<a name="1875"><span class="lineNum">    1875 </span>            :             // Make this a hybrid between greybox and blackbox fuzzing. Sometimes, instead of a mutating existing seed, test random input - if working, add it as seed.</a>
<a name="1876"><span class="lineNum">    1876 </span><span class="lineNoCov">          0 :             if (generators::randomFloat() &lt; greyness)</span></a>
<a name="1877"><span class="lineNum">    1877 </span>            :             {</a>
<a name="1878"><span class="lineNum">    1878 </span><span class="lineNoCov">          0 :                 trySeed(nullptr, generators::generateRandomInput());</span></a>
<a name="1879"><span class="lineNum">    1879 </span>            :             }</a>
<a name="1880"><span class="lineNum">    1880 </span>            :             else</a>
<a name="1881"><span class="lineNum">    1881 </span>            :             {</a>
<a name="1882"><span class="lineNum">    1882 </span><span class="lineNoCov">          0 :                 auto&amp; selected = queue-&gt;weightedRandomChoiceBorrow();</span></a>
<a name="1883"><span class="lineNum">    1883 </span><span class="lineNoCov">          0 :                 selected.incrementImproved();</span></a>
<a name="1884"><span class="lineNum">    1884 </span><span class="lineNoCov">          0 :                 trySeed(&amp;selected, randomNumberOfRandomMutants(selected.input));</span></a>
<a name="1885"><span class="lineNum">    1885 </span>            :             }</a>
<a name="1886"><span class="lineNum">    1886 </span>            :         }</a>
<a name="1887"><span class="lineNum">    1887 </span><span class="lineCov">          1 :     }</span></a>
<a name="1888"><span class="lineNum">    1888 </span>            : </a>
<a name="1889"><span class="lineNum">    1889 </span>            :     /// &lt;summary&gt;</a>
<a name="1890"><span class="lineNum">    1890 </span>            :     /// Populate a folder with random seeds</a>
<a name="1891"><span class="lineNum">    1891 </span>            :     /// &lt;/summary&gt;</a>
<a name="1892"><span class="lineNum">    1892 </span><span class="lineCov">          3 :     void populateWithMySeeds(size_t loadSize = 1000)</span></a>
<a name="1893"><span class="lineNum">    1893 </span>            :     {</a>
<a name="1894"><span class="lineNum">    1894 </span><span class="lineCov">          3 :         std::cerr &lt;&lt; &quot;Populating folder with my seed&quot; &lt;&lt; std::endl;</span></a>
<a name="1895"><span class="lineNum">    1895 </span><span class="lineCov">          3 :         std::filesystem::create_directories(INPUT_SEEDS);</span></a>
<a name="1896"><span class="lineNum">    1896 </span>            : </a>
<a name="1897"><span class="lineNum">    1897 </span><span class="lineCov">       3237 :         for (size_t i = 0; i &lt; loadSize; i++)</span></a>
<a name="1898"><span class="lineNum">    1898 </span>            :         {</a>
<a name="1899"><span class="lineNum">    1899 </span><span class="lineCov">       6468 :             std::filesystem::path path = INPUT_SEEDS / (std::to_string(i) + &quot;.txt&quot;);</span></a>
<a name="1900"><span class="lineNum">    1900 </span><span class="lineCov">       3234 :             std::ofstream outFile(path);</span></a>
<a name="1901"><span class="lineNum">    1901 </span><span class="lineCov">       3234 :             outFile &lt;&lt; generators::generateRandomInput();</span></a>
<a name="1902"><span class="lineNum">    1902 </span><span class="lineCov">       3234 :         }</span></a>
<a name="1903"><span class="lineNum">    1903 </span><span class="lineCov">          3 :     }</span></a>
<a name="1904"><span class="lineNum">    1904 </span>            : </a>
<a name="1905"><span class="lineNum">    1905 </span><span class="lineCov">          2 :     fuzzer_greybox(std::filesystem::path FUZZED_PROG, std::filesystem::path RESULT_FUZZ, bool MINIMIZE, std::string_view INPUT, std::chrono::seconds TIMEOUT, size_t NB_KNOWN_BUGS, POWER_SCHEDULE_T POWER_SCHEDULE, std::filesystem::path COVERAGE_FILE, float greyness, float concatenatedness, std::filesystem::path INPUT_SEEDS) : fuzzer(std::move(FUZZED_PROG), std::move(RESULT_FUZZ), std::move(MINIMIZE), std::move(INPUT), std::move(TIMEOUT), std::move(NB_KNOWN_BUGS)), POWER_SCHEDULE(std::move(POWER_SCHEDULE)), COVERAGE_FILE(std::move(COVERAGE_FILE)), INPUT_SEEDS(std::move(INPUT_SEEDS)), greyness(std::move(greyness)), concatenatedness(std::move(concatenatedness))</span></a>
<a name="1906"><span class="lineNum">    1906 </span>            :     {</a>
<a name="1907"><span class="lineNum">    1907 </span><span class="lineCov">          2 :         switch (POWER_SCHEDULE)</span></a>
<a name="1908"><span class="lineNum">    1908 </span>            :         {</a>
<a name="1909"><span class="lineNum">    1909 </span><span class="lineCov">          2 :         case fuzzer_greybox::POWER_SCHEDULE_T::simple:</span></a>
<a name="1910"><span class="lineNum">    1910 </span><span class="lineCov">          2 :             queue = std::make_unique&lt;powerSimple&gt;();</span></a>
<a name="1911"><span class="lineNum">    1911 </span><span class="lineCov">          2 :             break;</span></a>
<a name="1912"><span class="lineNum">    1912 </span><span class="lineNoCov">          0 :         case fuzzer_greybox::POWER_SCHEDULE_T::boosted:</span></a>
<a name="1913"><span class="lineNum">    1913 </span><span class="lineNoCov">          0 :             queue = std::make_unique&lt;powerBoosted&gt;();</span></a>
<a name="1914"><span class="lineNum">    1914 </span><span class="lineNoCov">          0 :             break;</span></a>
<a name="1915"><span class="lineNum">    1915 </span><span class="lineNoCov">          0 :         default:</span></a>
<a name="1916"><span class="lineNum">    1916 </span><span class="lineNoCov">          0 :             UNREACHABLE;</span></a>
<a name="1917"><span class="lineNum">    1917 </span>            :         }</a>
<a name="1918"><span class="lineNum">    1918 </span><span class="lineCov">          2 :     }</span></a>
<a name="1919"><span class="lineNum">    1919 </span>            : </a>
<a name="1920"><span class="lineNum">    1920 </span><span class="lineCov">          2 :     fuzzer_greybox(std::filesystem::path FUZZED_PROG, std::filesystem::path RESULT_FUZZ, bool MINIMIZE, std::string_view INPUT, std::chrono::seconds TIMEOUT, size_t NB_KNOWN_BUGS, POWER_SCHEDULE_T POWER_SCHEDULE, std::filesystem::path COVERAGE_FILE, float greyness, float concatenatedness) : fuzzer_greybox(std::move(FUZZED_PROG), std::move(RESULT_FUZZ), std::move(MINIMIZE), std::move(INPUT), std::move(TIMEOUT), std::move(NB_KNOWN_BUGS), std::move(POWER_SCHEDULE), std::move(COVERAGE_FILE), std::move(greyness), std::move(concatenatedness), &quot;MY_SEED&quot;)</span></a>
<a name="1921"><span class="lineNum">    1921 </span>            :     {</a>
<a name="1922"><span class="lineNum">    1922 </span><span class="lineCov">          2 :         populateWithMySeeds();</span></a>
<a name="1923"><span class="lineNum">    1923 </span><span class="lineCov">          2 :     }</span></a>
<a name="1924"><span class="lineNum">    1924 </span>            : </a>
<a name="1925"><span class="lineNum">    1925 </span>            :     const POWER_SCHEDULE_T POWER_SCHEDULE;</a>
<a name="1926"><span class="lineNum">    1926 </span>            :     const std::filesystem::path INPUT_SEEDS;</a>
<a name="1927"><span class="lineNum">    1927 </span>            :     const std::filesystem::path COVERAGE_FILE;</a>
<a name="1928"><span class="lineNum">    1928 </span>            : </a>
<a name="1929"><span class="lineNum">    1929 </span>            :     const float greyness;</a>
<a name="1930"><span class="lineNum">    1930 </span>            :     const float concatenatedness;</a>
<a name="1931"><span class="lineNum">    1931 </span>            : };</a>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.14</a></td></tr>
  </table>
  <br>

</body>
</html>
